import { uploadHistoricalData } from "../utils/historicalUpload";
import { StyleSheet, View, Text, ActivityIndicator, TouchableOpacity, Modal, TextInput, FlatList, Button, ScrollView, Alert, Platform } from "react-native";
import React, { useEffect, useState, useCallback } from "react";
import * as SecureStore from "expo-secure-store";
import { useRouter } from "expo-router";
import { getFirestore, collection, addDoc, Firestore } from "firebase/firestore";
import { initializeApp, FirebaseApp } from "firebase/app";
import AppleHealthKit, { 
  HealthValue,
  HealthInputOptions,
  HealthUnit,
  HealthObserver,
  HealthActivitySummary,
  HealthKitPermissions,
  HealthPermission
} from 'react-native-health';
import { doc, setDoc } from "firebase/firestore";  
import { getAuth, initializeAuth, Auth } from "firebase/auth";
import Constants from 'expo-constants';
import { AppState } from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { requestNotificationPermissions, scheduleDailySurveyReminder, getReminderTimePreference } from '../utils/notifications';
import NotificationTimePicker from '../components/NotificationTimePicker';

// Add type declarations for Apple HealthKit
declare module 'react-native-health' {
  interface AppleHealthKit {
    getAnchoredWorkouts(options: any, callback: (error: string | null, results: any) => void): void;
    getDailyStepCountSamples(options: any, callback: (error: string | null, results: any) => void): void;
    getDistanceWalkingRunning(options: any, callback: (error: string | null, results: any) => void): void;
    getSleepSamples(options: any, callback: (error: string | null, results: any[]) => void): void;
    getVo2MaxSamples(options: any, callback: (error: string | null, results: any[]) => void): void;
    getHeartRateVariabilitySamples(options: any, callback: (error: string | null, results: any[]) => void): void;
    getMindfulSession(options: any, callback: (error: string | null, results: any[]) => void): void;
    isAvailable(callback: (error: string, result: boolean) => void): void;
    getAuthStatus(permissions: any, callback: (error: string, result: any) => void): void;
    getBiologicalSex(options: any, callback: (error: string, results: any) => void): void;
    getHeightSamples(options: any, callback: (error: string, results: any) => void): void;
    getWeightSamples(options: any, callback: (error: string, results: any) => void): void;
    getDateOfBirth(options: any, callback: (error: string, results: any) => void): void;
  }
}

// Firebase configuration
const firebaseConfig = {
  apiKey: "AIzaSyBWzYmkdQj7LbVk7dIZzjsan_Eca9EQPrA",
  authDomain: "lift-c8dbf.firebaseapp.com",
  projectId: "lift-c8dbf",
  storageBucket: "lift-c8dbf.firebasestorage.app",
  messagingSenderId: "16228935546",
  appId: "1:16228935546:web:9615f3300e942f861f58c3",
  measurementId: "G-2B6SVW0YSS"
}

// API configuration
const API_URL = Constants.expoConfig?.extra?.apiUrl || 'https://dodo-holy-primarily.ngrok-free.app';

// Error messages
const ERROR_MESSAGES = {
  NETWORK: "Network error. Please check your internet connection.",
  SERVER: "Server error. Please try again later.",
  AUTH: "Authentication failed. Please check your credentials.",
  INIT: "Failed to initialize the app. Please try again."
}

// Initialize Firebase only if we're in a native environment
let app: FirebaseApp | undefined;
let auth: Auth | undefined;
let db: Firestore | undefined;

try {
  app = initializeApp(firebaseConfig);
  auth = initializeAuth(app);
  db = getFirestore(app);
} catch (error) {
  console.error('Firebase initialization error:', error);
}

interface HealthData {
  hrv: number;
  timestamp: Date;
  source: string;
}

interface GarminData {
  stress: {
    max_stress: number;
    avg_stress: number;
    date: string;
  } | null;
  hrv: {
    summary: {
      lastNightAvg: number;
      lastNight5MinHigh: number;
      status: string;
      feedbackPhrase: string;
    }
    readings: {
      time: string;
      value: number;
    }[];
  } | null;
  sleep: {
    summary: {
    total_sleep_seconds: number;
    deep_sleep_seconds: number;
    light_sleep_seconds: number;
    rem_sleep_seconds: number;
    awake_seconds: number;
      sleep_start: string;
      sleep_end: string;
    sleep_score: string;
      average_hrv: number;
      lowest_hrv: number;
      highest_hrv: number;
    }
    phases: {
      start_time: string;
      end_time: string;
      phase_type: string;
      duration_seconds: number;
      hrv: number;
    }[];
  } | null;
  activity: {
    steps: number;
    calories_burned: number;
    active_minutes: number;
    distance_km: number;
    floors_climbed: number;
    active_time_seconds: number;
    date: string;
    vo2_max: number;
    vo2_max_status: string;
    vo2_max_date: string;
    daily_activities: { type: string; duration_minutes: number }[];
    mindful_minutes: number;
  } | null;
  heart_rate: {
    resting_heart_rate: number;
    hrv_heart_rate: number;
    date: string;
  } | null;
}

interface HealthKitResponse {
      value: number;
  startDate: string;
  endDate: string;
}

interface SleepSample {
  startDate: string;
  endDate: string;
  value: 'INBED' | 'ASLEEP' | 'AWAKE' | 'CORE' | 'DEEP' | 'REM';
  sourceId?: string;
  sourceName?: string;
}

// Add styles for the new UI elements
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    padding: 20,
  },
  scrollView: {
    flex: 1,
  },
  scrollViewContent: {
    paddingBottom: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 20,
  },
  button: {
    backgroundColor: '#007AFF',
    padding: 12,
    borderRadius: 8,
    alignItems: 'center',
    marginVertical: 8,
  },
  buttonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
  },
  healthKitStatus: {
    color: 'green',
    marginVertical: 10,
    fontWeight: 'bold',
  },
  dataRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginVertical: 5,
  },
  dataLabel: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333',
  },
  dataValue: {
    fontSize: 16,
    color: '#333',
  },
  chartContainer: {
    height: 200,
    marginVertical: 20,
  },
  section: {
    marginVertical: 20,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 15,
    color: '#333'
  },
  hrvSummary: {
    backgroundColor: '#f5f8fa',
    padding: 15,
    borderRadius: 10,
    marginVertical: 10,
  },
  row: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginVertical: 5,
  },
  subRow: {
    marginLeft: 10,
    marginTop: 2,
  },
  subText: {
    fontSize: 12,
    color: '#666',
    fontStyle: 'italic',
  },
  label: {
    fontSize: 16,
    color: '#333',
  },
  value: {
    fontSize: 16,
    fontWeight: '500',
    color: '#333',
  },
  sleepSummary: {
    marginVertical: 10,
  },
  sleepTime: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 10,
    color: '#333',
  },
  noData: {
    color: '#666',
    fontStyle: 'italic',
    textAlign: 'center',
    marginVertical: 10,
  },
  modalContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
  },
  modalContent: {
    backgroundColor: 'white',
    padding: 20,
    borderRadius: 10,
    width: '95%',
    maxHeight: '90%',
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 20,
  },
  modalTitle: {
    fontSize: 20,
    fontWeight: 'bold',
  },
  closeButton: {
    fontSize: 24,
    color: '#333',
  },
  input: {
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 5,
    padding: 12,
    marginVertical: 6,
    fontSize: 16,
  },
  buttonPressed: {
    backgroundColor: '#ccc',
  },
  buttonContainer: {
    flexDirection: 'column',
    marginVertical: 15,
  },
  modalButtonContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 20,
    paddingHorizontal: 10,
  },
  questionContainer: {
    marginVertical: 15,
  },
  questionText: {
    fontSize: 16,
    marginBottom: 10,
  },
  likertContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  switchContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginVertical: 10,
  },
  switchLabel: {
    fontSize: 16,
  },
  activityRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginVertical: 5,
    paddingVertical: 5,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  activityType: {
    fontSize: 16,
    fontWeight: '500',
    color: '#333',
  },
  activityDuration: {
    fontSize: 16,
    color: '#666',
  },
  tab: {
    paddingVertical: 10,
    paddingHorizontal: 20,
    marginRight: 10,
    borderRadius: 20,
  },
  activeTab: {
    backgroundColor: '#007AFF',
  },
  tabText: {
    fontSize: 14,
  },
  activeTabText: {
    color: '#fff',
  },
  tabsContainer: {
    flexDirection: 'row',
    marginVertical: 15,
  },
  errorText: {
    color: 'red',
    marginVertical: 10,
  },
  appleButton: {
    backgroundColor: '#000',
  },
  garminButton: {
    backgroundColor: '#008ace',
  },
  sourceButtonContainer: {
    marginVertical: 20,
  },
  sourceButton: {
    backgroundColor: '#555',
    padding: 10,
    borderRadius: 5,
    marginVertical: 5,
  },
  sourceButtonText: {
    color: '#fff',
    fontSize: 14,
  },
  dropdownButton: {
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 5,
    padding: 12,
    marginVertical: 5,
  },
  dropdownButtonText: {
    color: '#333',
    fontSize: 16,
  },
  optionsList: {
    backgroundColor: '#fff',
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 5,
    marginTop: 5,
    maxHeight: 200,
  },
  textArea: {
    height: 100,
    textAlignVertical: 'top',
  },
  formGroup: {
    marginVertical: 12,
  },
  formLabel: {
    fontSize: 16,
    marginBottom: 5,
    color: '#333'
  },
  inputGroup: {
    marginVertical: 15,
  },
  halfInputContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  halfInput: {
    width: '48%',
  },
  loadingContainer: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: 'rgba(255, 255, 255, 0.7)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  infoText: {
    fontSize: 14,
    color: '#666',
    marginTop: 10,
    fontStyle: 'italic',
  },
  optionItem: {
    padding: 10,
    borderBottomWidth: 1,
    borderBottomColor: '#ddd',
    width: '100%'
  },
  optionText: {
    fontSize: 16,
    color: '#333'
  },
  selectedOption: {
    backgroundColor: '#f5f5f5',
  },
  selectedOptionText: {
    color: '#007AFF',
  },
  dailySurveyContainer: {
    marginTop: 20,
  },
  yesNoQuestion: {
    marginBottom: 10,
  },
  toggleButton: {
    padding: 10,
    borderWidth: 2,
    borderColor: '#ddd',
    borderRadius: 5,
    marginBottom: 5,
  },
  toggleButtonActive: {
    borderColor: '#007AFF',
  },
  toggleButtonText: {
    fontSize: 16,
    color: '#333',
  },
  toggleButtonTextActive: {
    color: '#007AFF',
  },
  modalFormContainer: {
    flex: 1,
    padding: 10,
  },
  dropdownButtonSelected: {
    borderColor: '#007AFF',
  },
  dropdownButtonTextSelected: {
    color: '#007AFF',
  },
  dropdownContent: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  dropdownArrow: {
    fontSize: 12,
    color: '#666',
    marginRight: 8,
  },
  buttonWithCheckbox: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
  },
  checkmark: {
    marginLeft: 8,
    fontSize: 18,
    color: '#fff',
    fontWeight: 'bold',
  },
  optionWrapper: {
    alignItems: 'center',
  },
  circleOption: {
    width: 18,
    height: 18,
    borderRadius: 9,
    borderWidth: 1,
    borderColor: '#ddd',
    alignItems: 'center',
    justifyContent: 'center',
  },
  innerCircle: {
    width: 9,
    height: 9,
    borderRadius: 4.5,
    backgroundColor: '#007AFF',
  },
  circleSelected: {
    borderColor: '#007AFF',
  },
  optionLabel: {
    fontSize: 10,
    color: '#333',
    textAlign: 'center',
    marginTop: 3,
  },
  labelSelected: {
    color: '#007AFF',
  },
  submitButton: {
    backgroundColor: '#007AFF',
    marginRight: 10,
  },
  cancelButton: {
    backgroundColor: '#ccc',
  },
  headerButtons: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 10,
  },
  refreshButton: {
    backgroundColor: '#4CAF50',
    padding: 8,
    borderRadius: 8,
    width: 35,
    height: 35,
    justifyContent: 'center',
    alignItems: 'center',
  },
  refreshButtonText: {
    fontSize: 20,
    color: '#fff',
    fontWeight: 'bold',
  },
  hrvReadingsContainer: {
    flexDirection: 'row',
    marginTop: 8,
    marginBottom: 12,
  },
  hrvReading: {
    backgroundColor: '#f0f0f0',
    borderRadius: 8,
    padding: 12,
    marginRight: 8,
    minWidth: 80,
    alignItems: 'center',
  },
  hrvValue: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#007AFF',
  },
  hrvTime: {
    fontSize: 12,
    color: '#666',
    marginTop: 4,
  },
  subsectionTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#444',
    marginTop: 16,
    marginBottom: 8,
  },
  noActivities: {
    fontSize: 14,
    color: '#666',
    fontStyle: 'italic',
    textAlign: 'center',
    padding: 12,
  },
  modalButtons: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 20,
    paddingHorizontal: 10,
  },
  autoFillButton: {
    backgroundColor: '#4A90E2',
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 4,
    marginRight: 10,
    flex: 1,
  },
  autoFillButtonText: {
    color: 'white',
    fontWeight: 'bold',
    textAlign: 'center',
  },
  modalSubmitButton: {
    backgroundColor: '#28a745',
    borderRadius: 5,
    paddingVertical: 12,
    paddingHorizontal: 16,
    minWidth: 120,
  },
  modalButtonText: {
    color: 'white',
    fontWeight: 'bold',
    textAlign: 'center',
  },
  subQuestionContainer: {
    marginTop: 10,
    marginLeft: 20,
    flexDirection: 'column',
    alignItems: 'flex-start',
    gap: 10,
  },
  subQuestionText: {
    fontSize: 16,
    color: '#666',
    marginBottom: 5,
  },
  subOptionButton: {
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 5,
    marginVertical: 2,
    alignSelf: 'flex-start',
  },
  subOptionButtonActive: {
    borderColor: '#007AFF',
  },
  subOptionText: {
    fontSize: 14,
    color: '#333',
  },
  subOptionTextActive: {
    color: '#007AFF',
  },
  otherTextInput: {
    width: '100%',
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 5,
    padding: 10,
    marginVertical: 5,
  },
  emotionsContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-around',
    marginHorizontal: 10,
    marginBottom: 20,
  },
  emotionButton: {
    width: '45%',
    padding: 10,
    margin: 5,
    borderWidth: 2,
    borderColor: '#ddd',
    borderRadius: 10,
    alignItems: 'center',
    marginBottom: 10,
  },
  emotionEmoji: {
    fontSize: 24,
    marginBottom: 5,
  },
  emotionText: {
    fontSize: 16,
  },
  emotionButtonActive: {
    borderColor: '#007AFF',
  },
  emotionTextActive: {
    color: '#007AFF',
  },
  rowContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  centeredView: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0,0,0,0.5)',
  },
  modalView: {
    width: '80%',
    backgroundColor: 'white',
    borderRadius: 20,
    padding: 35,
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 4,
    elevation: 5,
  },
  closeButtonText: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#007AFF',
  },
  sectionText: {
    fontSize: 18,
    marginBottom: 10,
    textAlign: 'center',
  },
});

// Add this new function to handle device ID generation and storage
const getOrCreateDeviceId = async (): Promise<string> => {
  try {
    // Try to get existing device ID
    let existingDeviceId = await SecureStore.getItemAsync('device_id');
    
    if (existingDeviceId) {
      return existingDeviceId;
    }
    
    // If no device ID exists, create a new one
    const newDeviceId = `device_${Date.now()}_${Math.random().toString(36).substring(7)}`;
    await SecureStore.setItemAsync('device_id', newDeviceId);
    return newDeviceId;
  } catch (error) {
    console.error('Error handling device ID:', error);
    throw error;
  }
}

const HomeScreen = () => {
  const router = useRouter();
  const [isInitialized, setIsInitialized] = useState(false);
  const [initError, setInitError] = useState<string | null>(null);
  const [stressData, setStressData] = useState<HealthData | null>(null);
  const [loading, setLoading] = useState(false);
  const [garminModalVisible, setGarminModalVisible] = useState(false);
  const [pssModalVisible, setPssModalVisible] = useState(false);
  const [personalInfoModalVisible, setPersonalInfoModalVisible] = useState(false);
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [name, setName] = useState("");
  const [responses, setResponses] = useState([0, 0, 0, 0]);
  const [otherText, setOtherText] = useState("");
  // New daily survey response states for yes/no questions
  const [dailySurveyResponses, setDailySurveyResponses] = useState({
    seasonal_allergies: false,
    sick: false,
    alcohol: false,
    smoking: false,
    caffeine: false,
    bright_lights: false,
    phone_in_bed: false,
    processed_food: false,
    late_meal: false,
    water_3l: false,
    morning_sunlight: false,
    meditation: false,
    exercise: false,
    exercise_type: "",
    exercise_duration: "",
    met_friends: false,
    journaling: false,
    reading: false,
    relaxation: false,
    relaxation_duration: "",
    relaxation_meditation: false,
    relaxation_breathing: false,
    relaxation_journaling: false,
    relaxation_music: false,
    relaxation_other: false,
    relaxation_other_text: "",
    emotion_happiness: false,
    emotion_anxiety: false,
    emotion_sadness: false,
    emotion_anger: false,
    emotion_relaxation: false
  });
  const [healthKitAvailable, setHealthKitAvailable] = useState(false);
  const [personalInfo, setPersonalInfo] = useState({
    age: null as number | null,
    gender: "" as string,
    height: null as number | null,
    weight: null as number | null,
    fitness_level: null as number | null,
    stress_level: null as number | null,
    sleep_quality: null as number | null,
    pre_existing_conditions: "" as string,
    allergies: "" as string,
    smoker: "" as string,
    alcohol_consumption: "" as string,
    firstname: "" as string,
    lastname: "" as string,
    marijuana_consumption: "" as string,
    diet_type: "" as string,
    cold_showers: "" as string,
    meditation: "" as string,
    sauna_use: "" as string,
    sleep_medication: "" as string,
    blue_light_glasses: "" as string,
    intermittent_fasting: "" as string,
    sleep_mask: "" as string,
    seasonal_allergies: "" as string,
    caffeine_consumption: "" as string,
  });
  const [garminData, setGarminData] = useState<GarminData>({
    stress: null,
    hrv: null,
    sleep: null,
    activity: null,
    heart_rate: null
  });

  const [dataSource, setDataSource] = useState<'garmin' | 'apple' | null>('apple');
  const [sourceSelectionVisible, setSourceSelectionVisible] = useState(true);
  const [deviceId, setDeviceId] = useState<string | null>(null);
  const [isModalTransitioning, setIsModalTransitioning] = useState(false);
  const [activeModal, setActiveModal] = useState<'garmin' | 'pss' | 'personal' | null>(null);
  const [isAutoFilling, setIsAutoFilling] = useState(false);
  const [surveySubmitted, setSurveySubmitted] = useState(false);
  const [lastSurveyDate, setLastSurveyDate] = useState<string | null>(null);
  const [personalInfoSubmitted, setPersonalInfoSubmitted] = useState(false);
  const [historyDataUploaded, setHistoryDataUploaded] = useState(false);

  // PSS questions
  const questions = [
    "How stressed do you feel right now?",
    "How well did you sleep last night?",
    "How rested do you feel right now?",
    "What is the first thing on your mind this morning?"
  ];

  const getOptionsForQuestion = (questionIndex: number) => {
    switch (questionIndex) {
      case 0: // Stress scale 0-10
        return Array.from({ length: 11 }, (_, i) => ({ 
          value: i, 
          label: i.toString() 
        }));
      case 1: // Sleep quality
        return [
          { value: 1, label: "Very Poor" },
          { value: 2, label: "Poor" },
          { value: 3, label: "Average" },
          { value: 4, label: "Good" },
          { value: 5, label: "Excellent" }
        ];
      case 2: // Rest feeling
        return [
          { value: 1, label: "Not rested at all" },
          { value: 2, label: "Slightly rested" },
          { value: 3, label: "Moderately rested" },
          { value: 4, label: "Well rested" },
          { value: 5, label: "Very well rested" }
        ];
      case 3: // First thing on mind
        return [
          { value: 1, label: "Work/School" },
          { value: 2, label: "Personal concerns" },
          { value: 3, label: "Excitement/Positive anticipation" },
          { value: 4, label: "Health/Physical discomfort" },
          { value: 5, label: "Other" }
        ];
      default:
        return [];
    }
  }

  const likertOptions = [
    { value: 1, label: "1" },
    { value: 2, label: "2" },
    { value: 3, label: "3" },
    { value: 4, label: "4" },
    { value: 5, label: "5" }
  ];

  // Add a more sophisticated modal manager
  const [modalManager, setModalManager] = useState({
    activeModal: null as 'garmin' | 'pss' | 'personal' | null,
    isTransitioning: false,
    previousModal: null as 'garmin' | 'pss' | 'personal' | null,
    queuedModal: null as 'garmin' | 'pss' | 'personal' | null
  });

  // Create safe modal control functions
  const openModal = (modalType: 'garmin' | 'pss' | 'personal') => {
    
    
    // If already in transition, queue this request
    if (modalManager.isTransitioning) {
      
      setModalManager(prev => ({...prev, queuedModal: modalType}));
      return;
    }
    
    // If the requested modal is already active, do nothing
    if (modalManager.activeModal === modalType) {
      
      return;
    }
    
    // Start transition
    setModalManager(prev => ({
      ...prev, 
      isTransitioning: true,
      previousModal: prev.activeModal
    }));
    
    // Close any active modal first
    if (modalManager.activeModal) {
      
      
      // Close the appropriate modal
      switch (modalManager.activeModal) {
        case 'garmin':
          setGarminModalVisible(false);
          break;
        case 'pss':
          setPssModalVisible(false);
          break;
        case 'personal':
          setPersonalInfoModalVisible(false);
          break;
      }
      
      // Wait for animation to complete before opening new modal
      setTimeout(() => {
        
        switch (modalType) {
          case 'garmin':
            setGarminModalVisible(true);
            if (dataSource === 'garmin') {
              setTimeout(checkGarminCredentials, 500);
            }
            break;
          case 'pss':
            setPssModalVisible(true);
            break;
          case 'personal':
            setPersonalInfoModalVisible(true);
            break;
        }
        
        setModalManager(prev => ({
          ...prev,
          activeModal: modalType,
          isTransitioning: false
        }));
        
        // Process any queued modal after a short delay
        setTimeout(() => {
          setModalManager(prev => {
            if (prev.queuedModal) {
              
              openModal(prev.queuedModal);
              return {...prev, queuedModal: null}
            }
            return prev;
          });
        }, 100);
      }, 400); // Wait 400ms for animation
    } else {
      // No active modal, open directly
      
      switch (modalType) {
        case 'garmin':
          setGarminModalVisible(true);
          if (dataSource === 'garmin') {
            setTimeout(checkGarminCredentials, 500);
          }
          break;
        case 'pss':
          setPssModalVisible(true);
          break;
        case 'personal':
          setPersonalInfoModalVisible(true);
          break;
      }
      
      setModalManager(prev => ({
        ...prev,
        activeModal: modalType,
        isTransitioning: false
      }));
    }
  }

  const closeModal = (modalType: 'garmin' | 'pss' | 'personal') => {
    
    
    // Only close if this modal is active
    if (modalManager.activeModal !== modalType) {
      
      return;
    }
    
    // If already in transition, ignore
    if (modalManager.isTransitioning) {
      
      return;
    }
    
    setModalManager(prev => ({...prev, isTransitioning: true}));
    
    // Close the appropriate modal
    switch (modalType) {
      case 'garmin':
        setGarminModalVisible(false);
        break;
      case 'pss':
        setPssModalVisible(false);
        break;
      case 'personal':
        setPersonalInfoModalVisible(false);
        break;
    }
    
    // Reset modal state after animation
    setTimeout(() => {
      setModalManager(prev => ({
        ...prev,
        activeModal: null,
        isTransitioning: false,
        previousModal: modalType
      }));
      
      // Process any queued modal
      setTimeout(() => {
        setModalManager(prev => {
          if (prev.queuedModal) {
            
            openModal(prev.queuedModal);
            return {...prev, queuedModal: null}
          }
          return prev;
        });
      }, 100);
    }, 400);
  }

  // Helper functions for processing health data
  const processSleepData = (sleepData: SleepSample[] | null) => {
    if (!sleepData || sleepData.length === 0) {
      console.error("No sleep data available");
      return { startTime: null, endTime: null, totalSleep: 0 }
    }

    let totalSleep = 0;
    let deepSleep = 0;
    let lightSleep = 0;
    let remSleep = 0;
    let awake = 0;
    let startTime = '';
    let endTime = '';
    let phases: any[] = [];

    if (sleepData.length > 0) {
      // Sort sleep samples by start time
      const sortedSamples = sleepData.sort((a: any, b: any) => 
        new Date(a.startDate).getTime() - new Date(b.startDate).getTime()
      );

      startTime = sortedSamples[0].startDate;
      endTime = sortedSamples[sortedSamples.length - 1].endDate;

      sleepData.forEach((sample: SleepSample) => {
        const duration = (new Date(sample.endDate).getTime() - new Date(sample.startDate).getTime()) / 1000;
        
        // Map Apple Health sleep stages to our categories
        switch (sample.value) {
          case 'DEEP':
            deepSleep += duration;
            break;
          case 'CORE':
            lightSleep += duration;
            break;
          case 'REM':
            remSleep += duration;
            break;
          case 'AWAKE':
            awake += duration;
            break;
          case 'ASLEEP': // For older iOS versions that don't provide detailed stages
            // In this case, we'll still need to estimate the distribution
            deepSleep += Math.round(duration * 0.2);
            lightSleep += Math.round(duration * 0.6);
            remSleep += Math.round(duration * 0.2);
            break;
          case 'INBED':
            // Only count "in bed" time if it's not overlapping with other sleep stages
            if (!sleepData.some(other => 
              other !== sample &&
              new Date(other.startDate) <= new Date(sample.endDate) &&
              new Date(other.endDate) >= new Date(sample.startDate)
            )) {
              awake += duration;
            }
            break;
        }

        phases.push({
          start_time: sample.startDate,
          end_time: sample.endDate,
          phase_type: sample.value,
          duration_seconds: duration,
          source: sample.sourceName || 'Unknown'
        });
      });

      totalSleep = deepSleep + lightSleep + remSleep;
    }

    return {
      totalSleep,
      deepSleep,
      lightSleep,
      remSleep,
      awake,
      startTime,
      endTime,
      phases
    }
  }

  const calculateAverageHRV = (hrvData: HealthValue[], sleepStart: string, sleepEnd: string) => {
    if (hrvData.length === 0) return 0;
    
    // If we have sleep times, filter for sleep period
    if (sleepStart && sleepEnd) {
      const sleepStartTime = new Date(sleepStart).getTime();
      const sleepEndTime = new Date(sleepEnd).getTime();
      
      // Filter HRV readings that occurred during sleep
      const sleepHrvData = hrvData.filter(reading => {
        const readingTime = new Date(reading.startDate).getTime();
        return readingTime >= sleepStartTime && readingTime <= sleepEndTime;
      });

      if (sleepHrvData.length > 0) {
        const sum = sleepHrvData.reduce((acc, curr) => acc + curr.value, 0);
        return Math.round(sum / sleepHrvData.length);
      }
    }
    
    // If no sleep data or no readings during sleep, use all readings
    const sum = hrvData.reduce((acc, curr) => acc + curr.value, 0);
    return Math.round(sum / hrvData.length);
  }

  const findHighestHRV = (hrvData: HealthValue[], sleepStart: string, sleepEnd: string) => {
    if (hrvData.length === 0) return 0;
    
    // If we have sleep times, filter for sleep period
    if (sleepStart && sleepEnd) {
      const sleepStartTime = new Date(sleepStart).getTime();
      const sleepEndTime = new Date(sleepEnd).getTime();
      
      // Filter HRV readings that occurred during sleep
      const sleepHrvData = hrvData.filter(reading => {
        const readingTime = new Date(reading.startDate).getTime();
        return readingTime >= sleepStartTime && readingTime <= sleepEndTime;
      });

      if (sleepHrvData.length > 0) {
        return Math.max(...sleepHrvData.map(d => d.value));
      }
    }
    
    // If no sleep data or no readings during sleep, use all readings
    return Math.max(...hrvData.map(d => d.value));
  }

  const calculateActiveMinutes = (heartRateData: any[]) => {
    // Calculate active minutes based on heart rate and workouts
    let activeMinutes = 0;

    // 1. Calculate minutes where heart rate is in active zone (above 100 BPM)
    if (heartRateData && heartRateData.length > 0) {
      const activeHeartRateReadings = heartRateData.filter(hr => hr.value > 100);
      // Assuming readings are roughly 1 minute apart
      activeMinutes += activeHeartRateReadings.length;
    }

    return activeMinutes;
  }

  const calculateRestingHeartRate = (heartRateData: any[]) => {
    if (heartRateData.length === 0) return 0;
    // Use the lowest 10% of heart rate values to estimate resting heart rate
    const sortedHR = heartRateData.map((hr: any) => hr.value).sort((a, b) => a - b);
    const tenPercentile = Math.floor(sortedHR.length * 0.1);
    const restingHRs = sortedHR.slice(0, tenPercentile);
    return Math.round(restingHRs.reduce((a, b) => a + b, 0) / restingHRs.length);
  }

  const calculateAverageHeartRate = (heartRateData: any[]) => {
    if (heartRateData.length === 0) return 0;
    const sum = heartRateData.reduce((acc: number, curr: any) => acc + curr.value, 0);
    return Math.round(sum / heartRateData.length);
  }

  const fetchHRVData = async () => {
    setLoading(true);
    if (dataSource === 'garmin') {
      setLoading(false);
      return;
    }

    try {
      const now = new Date();
            // Set start date to beginning of yesterday (00:00:00)
      const startDate = new Date();
      startDate.setDate(now.getDate() - 1);
      startDate.setHours(0, 0, 0, 0);
      
      // Set end date to end of yesterday (23:59:59)
      const endDate = new Date();
      endDate.setDate(now.getDate() - 1);
      endDate.setHours(23, 59, 59, 999);

      // For sleep data, we want to look at a wider window to catch the full sleep period
      // From 6 PM two days ago to 11 AM yesterday
      const sleepStartDate = new Date();
      sleepStartDate.setDate(now.getDate() - 1);
      sleepStartDate.setHours(18, 0, 0, 0); // 6 PM
      
      const sleepEndDate = new Date();
      sleepEndDate.setDate(now.getDate());
      sleepEndDate.setHours(11, 0, 0, 0); // 11 AM
      
      
                                    const options = {
        startDate: startDate.toISOString(),
        endDate: endDate.toISOString(),
        ascending: false,
        limit: 288, // Increased limit to ensure we get all data points for the day (one reading every 5 minutes)
      }

      const sleepOptions = {
        startDate: sleepStartDate.toISOString(),
        endDate: sleepEndDate.toISOString(),
        ascending: true,
        limit: 288,
      }

                  // Initialize default values
      let steps = { value: 0 }
      let calories = { value: 0 }
      let distance = { value: 0 }
      let workouts = { activeMinutes: 0, activities: [] }
      let vo2Max = { value: 0, date: '', status: 'N/A' }
      let mindfulMinutes = 0; // Initialize mindful minutes

      // Fetch workouts first to calculate active minutes
      try {
        const workoutResults = await new Promise<any[]>((resolve, reject) => {
          if (typeof AppleHealthKit.getAnchoredWorkouts !== 'function') {
            resolve([]);
            return;
          }
          AppleHealthKit.getAnchoredWorkouts(
            {
              ...options,
              type: 'Workout'
            },
            (err: string | null, results: any) => {
              if (err) {
                console.error('Error fetching workouts:', err);
                resolve([]);
              } else if (results && Array.isArray(results.data)) {
                
                                const activities = results.data.map(workout => ({
                  type: workout.activityName || 'Unknown Activity',
                  duration_minutes: Math.round((workout.duration || 0) / 60)
                }));

                const totalActiveMinutes = activities.reduce((total, activity) => 
                  total + activity.duration_minutes, 0);

                resolve({
                  activeMinutes: totalActiveMinutes,
                  activities: activities,
                  anchor: results.anchor
                });
              } else {
                resolve({ activeMinutes: 0, activities: [], anchor: null });
              }
            }
          );
        });
        workouts = workoutResults;
      } catch (error) {
        console.error('Error fetching workouts:', error);
      }

      // Safely fetch each metric with error handling
      try {
        const stepsResult = await new Promise<any>((resolve, reject) => {
          if (typeof AppleHealthKit.getDailyStepCountSamples !== 'function') {
            resolve({ value: 0 });
            return;
          }
          AppleHealthKit.getDailyStepCountSamples(
            {
              ...options,
              includeManuallyAdded: true,
            },
            (err: string | null, results: any[]) => {
              if (err) {
                console.error('Error fetching steps:', err);
                resolve({ value: 0 });
              } else if (Array.isArray(results)) {
                
                                const totalSteps = results.reduce((sum: number, item: any) => sum + (item.value || 0), 0);
                resolve({ value: totalSteps });
              } else {
                resolve({ value: 0 });
              }
            }
          );
        });
        steps = stepsResult;
      } catch (error) {
        console.error('Error fetching steps:', error);
      }

      try {
        const caloriesResult = await new Promise<any>((resolve, reject) => {
          if (typeof AppleHealthKit.getActiveEnergyBurned !== 'function') {
            resolve({ value: 0 });
            return;
          }
          AppleHealthKit.getActiveEnergyBurned(
            {
              ...options,
              includeManuallyAdded: true,
            },
            (err: string | null, results: any[]) => {
              if (err) {
                console.error('Error fetching calories:', err);
                resolve({ value: 0 });
              } else if (Array.isArray(results)) {
                const totalCalories = results.reduce((sum: number, item: any) => sum + (item.value || 0), 0);
                resolve({ value: totalCalories });
              } else {
                resolve({ value: 0 });
              }
            }
          );
        });
        calories = caloriesResult;
      } catch (error) {
        console.error('Error fetching calories:', error);
      }

      try {
        const distanceResult = await new Promise<any>((resolve, reject) => {
          
          if (typeof AppleHealthKit.getDailyDistanceWalkingRunningSamples !== 'function') {
            console.error("‚ùå getDailyDistanceWalkingRunningSamples function not available");
            resolve({ value: 0 });
            return;
          }
          
          AppleHealthKit.getDailyDistanceWalkingRunningSamples(
            {
              startDate: options.startDate,
              endDate: options.endDate,
              unit: 'km',
              ascending: false
            },
            (err, results) => {
              if (err) {
                console.error('‚ùå Error fetching distance samples:', err);
                resolve({ value: 0 });
              } else if (Array.isArray(results) && results.length > 0) {
                // Sum up all distance values in the array
                const totalDistance = results.reduce((sum, item) => 
                  sum + (item.value || 0), 0) / 1000; // Convert from meters to kilometers
                console.log(`üèÉ‚Äç‚ôÇÔ∏è Total distance from ${results.length} daily samples: ${totalDistance} km`);
                resolve({ value: totalDistance });
              } else {
                console.log("‚ùå No distance data available in the specified period");
                resolve({ value: 0 });
              }
            }
          );
        });
        distance = distanceResult;
        
      } catch (error) {
        console.error('Error fetching distance:', error);
      }

      // Fetch HRV Data with proper error handling
      let hrvData: HealthValue[] = [];
      try {
        hrvData = await new Promise<HealthValue[]>((resolve, reject) => {
          AppleHealthKit.getHeartRateVariabilitySamples(
            {
              ...sleepOptions,
              unit: 'ms',
            },
            (err: string | null, results: HealthValue[]) => {
              if (err) {
                console.error('Error fetching HRV:', err);
                resolve([]);
              } else if (Array.isArray(results)) {
                
                if (results.length > 0) {
                  
                                  }
                                resolve(results.map(result => ({
                  ...result,
                  value: result.value * 1000
                })));
              } else {
                resolve([]);
              }
            }
          );
        });
      } catch (error) {
        console.error('Error fetching HRV:', error);
      }

      // Fetch Sleep Data with proper error handling
      let sleepData: any[] = [];
      try {
        sleepData = await new Promise<any[]>((resolve, reject) => {
          if (typeof AppleHealthKit.getSleepSamples !== 'function') {
            resolve([]);
            return;
          }
          AppleHealthKit.getSleepSamples(
            {
              ...sleepOptions,
              type: 'SleepAnalysis',
              includeStages: true
            },
            (err: string | null, results: any[]) => {
              if (err) {
                console.error('Error fetching sleep:', err);
                resolve([]);
              } else if (Array.isArray(results)) {
                
                
                                resolve(results);
              } else {
                resolve([]);
              }
            }
          );
        });
      } catch (error) {
        console.error('Error fetching sleep:', error);
      }

      // Process Sleep Data
      const sleepSummary = processSleepData(sleepData);

      // Fetch VO2 Max
      try {
        const vo2MaxResults = await new Promise<any>((resolve, reject) => {
          if (typeof AppleHealthKit.getVo2MaxSamples !== 'function') {
            resolve({ value: 0, date: '', status: 'N/A' });
            return;
          }
          AppleHealthKit.getVo2MaxSamples(
            {
              unit: 'mL/(kg*min)',
              ascending: false,
              limit: 1
            },
            (err: string | null, results: any[]) => {
              if (err) {
                console.error('Error fetching VO2 Max:', err);
                resolve({ value: 0, date: '', status: 'N/A' });
              } else if (Array.isArray(results) && results.length > 0) {
                const latest = results[0];
                resolve({
                  value: parseFloat(latest.value),
                  date: latest.startDate,
                  status: latest.value > 0 ? 'Available' : 'N/A'
                });
              } else {
                resolve({ value: 0, date: '', status: 'N/A' });
              }
            }
          );
        });
        vo2Max = vo2MaxResults;
      } catch (error) {
        console.error('Error fetching VO2 Max:', error);
      }

      // Fetch mindfulness sessions
      try {
        // Initialize mindfulMinutes to 0
        mindfulMinutes = 0;
        
        // Fetch mindfulness sessions from HealthKit
        const mindfulnessData = await new Promise<any[]>((resolve, reject) => {
          if (typeof AppleHealthKit.getMindfulSession !== 'function') {
            
            resolve([]);
            return;
          }
          
          AppleHealthKit.getMindfulSession(
            {
              ...options,
              type: 'MindfulSession'
            },
            (err: string | null, results: any[]) => {
              if (err) {
                console.error('Error fetching mindfulness sessions:', err);
                resolve([]);
              } else if (Array.isArray(results)) {
                
                                resolve(results);
              } else {
                resolve([]);
              }
            }
          );
        });
        
        // Calculate total mindfulness minutes
        if (mindfulnessData && mindfulnessData.length > 0) {
          mindfulnessData.forEach(session => {
            if (session.startDate && session.endDate) {
              const start = new Date(session.startDate);
              const end = new Date(session.endDate);
              const durationMinutes = (end.getTime() - start.getTime()) / (1000 * 60);
              mindfulMinutes += durationMinutes;
            }
          });
          
          // Round to nearest integer
          mindfulMinutes = Math.round(mindfulMinutes);
          
        }
      } catch (error) {
        console.error('Error fetching mindfulness data:', error);
      }

      // Update state with all the data
      setGarminData({
        stress: null,
        hrv: {
          summary: {
            lastNightAvg: sleepSummary && sleepSummary.startTime && sleepSummary.endTime ? 
              calculateAverageHRV(hrvData, sleepSummary.startTime, sleepSummary.endTime) : 
              (hrvData.length ? Math.round(hrvData.reduce((sum, item) => sum + item.value, 0) / hrvData.length) : 0),
            lastNight5MinHigh: sleepSummary && sleepSummary.startTime && sleepSummary.endTime ? 
              findHighestHRV(hrvData, sleepSummary.startTime, sleepSummary.endTime) : 
              (hrvData.length ? Math.max(...hrvData.map(d => d.value)) : 0),
            status: 'Available',
            feedbackPhrase: ''
          },
          readings: sleepSummary && sleepSummary.startTime && sleepSummary.endTime ? 
            hrvData
              .filter(reading => {
                const readingTime = new Date(reading.startDate).getTime();
                const sleepStartTime = new Date(sleepSummary.startTime).getTime();
                const sleepEndTime = new Date(sleepSummary.endTime).getTime();
                return readingTime >= sleepStartTime && readingTime <= sleepEndTime;
              })
              .map(reading => ({
                time: reading.startDate,
                value: Math.round(reading.value)
              })) : 
            hrvData.map(reading => ({
              time: reading.startDate,
              value: Math.round(reading.value)
            }))
        },
        sleep: {
          summary: {
            total_sleep_seconds: sleepSummary?.totalSleep || 0,
            deep_sleep_seconds: sleepSummary?.deepSleep || 0,
            light_sleep_seconds: sleepSummary?.lightSleep || 0,
            rem_sleep_seconds: sleepSummary?.remSleep || 0,
            awake_seconds: sleepSummary?.awake || 0,
            sleep_start: sleepSummary?.startTime || '',
            sleep_end: sleepSummary?.endTime || '',
            sleep_score: 'N/A',
            average_hrv: sleepSummary && sleepSummary.startTime && sleepSummary.endTime ? 
              calculateAverageHRV(hrvData, sleepSummary.startTime, sleepSummary.endTime) : 
              (hrvData.length ? Math.round(hrvData.reduce((sum, item) => sum + item.value, 0) / hrvData.length) : 0),
            lowest_hrv: hrvData.length ? Math.min(...hrvData.map(d => d.value)) : 0,
            highest_hrv: hrvData.length ? Math.max(...hrvData.map(d => d.value)) : 0
          },
          phases: sleepSummary?.phases || []
        },
        activity: {
          steps: steps.value || 0,
          calories_burned: Math.round(calories.value) || 0,
          active_minutes: workouts.activeMinutes || 0,
          distance_km: (distance.value || 0) / 1000,
          floors_climbed: 0,
          active_time_seconds: (workouts.activeMinutes || 0) * 60,
          date: now.toISOString().split('T')[0],
          vo2_max: vo2Max.value || 0,
          vo2_max_status: vo2Max.status,
          vo2_max_date: vo2Max.date,
          daily_activities: workouts.activities || [],
          mindful_minutes: mindfulMinutes || 0
        },
        heart_rate: {
          resting_heart_rate: calculateRestingHeartRate(hrvData),
          hrv_heart_rate: calculateAverageHeartRate(hrvData),
          date: now.toISOString().split('T')[0]
        }
      });

      // Upload data inside the try block
      await uploadGarminData(garminData);
    } catch (error) {
      console.error("Error fetching health data:", error);
    } finally {
      setLoading(false);
    }
  }

  const uploadGarminData = async (garminData: GarminData) => {
    if (!db) {
      console.error('Firebase not initialized');
      Alert.alert('Error', 'Database connection not available');
      return;
    }

    const firestore = db as Firestore;

    try {
      // Get or create device ID
      const currentDeviceId = await getOrCreateDeviceId();

      // Add timestamp and format data for upload
      const dataToUpload = {
        ...garminData,
        timestamp: new Date(),
        deviceId: currentDeviceId,
        uploadDate: new Date().toISOString().split('T')[0]
      }

      // Upload to device-specific collection
      const deviceGarminRef = doc(firestore, `devices/${currentDeviceId}/garminData`, new Date().toISOString().split('T')[0]);
      await setDoc(deviceGarminRef, dataToUpload);

      // Upload to main collection for aggregated data
      const mainGarminRef = doc(collection(firestore, 'garminData'), `${currentDeviceId}_${new Date().toISOString().split('T')[0]}`);
      await setDoc(mainGarminRef, dataToUpload);

      
    } catch (error) {
      console.error("Error uploading Garmin data:", error);
      Alert.alert('Error', 'Failed to upload data to database');
      throw error;
    }
  }

  const fetchGarminData = async (storedEmail: string, storedPassword: string) => {
    setLoading(true);
    try {
      // Calculate yesterday's date
      const now = new Date();
      const yesterday = new Date(now);
      yesterday.setDate(yesterday.getDate() - 1);
      const targetDate = yesterday.toISOString().split('T')[0];  // Format: YYYY-MM-DD
      
      
      
      const requestBody = { 
        email: storedEmail, 
        password: storedPassword, 
        date: targetDate 
      }
      
      
      const response = await fetch(`${API_URL}/all_data`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(requestBody),
      });

      if (!response.ok) {
        const errorText = await response.text();
        console.error('Server response:', response.status, errorText);
        if (response.status === 401) {
          throw new Error(ERROR_MESSAGES.AUTH);
        } else if (response.status === 502) {
          throw new Error("Server is not responding. Please check if the backend server is running.");
        }
        throw new Error(`Server error: ${response.status} - ${errorText}`);
      }

      const data = await response.json();
      
      // Save current data to preserve Apple HealthKit values if needed
      const currentData = {...garminData}
      
      // Make sure activity structure exists
      if (!data.activity) {
        data.activity = {
          steps: 0,
          calories_burned: 0,
          active_minutes: 0,
          distance_km: 0,
          floors_climbed: 0,
          active_time_seconds: 0,
          date: targetDate,
          vo2_max: 0,
          vo2_max_status: 'N/A',
          vo2_max_date: '',
          daily_activities: [],
          mindful_minutes: 0
        }
      }
      
      // If there are no real values from Garmin but we have Apple HealthKit data, preserve it
      if (currentData.activity) {
        // Check if Garmin data is zero/null but we have values from Apple
        if (data.activity.steps === 0 && currentData.activity.steps > 0) {
          
          data.activity.steps = currentData.activity.steps;
        }
        
        if (data.activity.calories_burned === 0 && currentData.activity.calories_burned > 0) {
          
          data.activity.calories_burned = currentData.activity.calories_burned;
        }
        
        if (data.activity.distance_km === 0 && currentData.activity.distance_km > 0) {
          
          data.activity.distance_km = currentData.activity.distance_km;
        }
        
        if (data.activity.mindful_minutes === 0 && currentData.activity.mindful_minutes > 0) {
          
          data.activity.mindful_minutes = currentData.activity.mindful_minutes;
        }
      } else if (!data.activity.mindful_minutes) {
        // Ensure mindful_minutes is at least initialized
        data.activity.mindful_minutes = 0;
      }
      
      setGarminData(data);
      await uploadGarminData(data);
    } catch (error) {
      console.error("Error fetching Garmin data:", error);
      if (error instanceof Error) {
        if (error.message.includes('Network request failed')) {
          Alert.alert(
            'Connection Error',
            'Unable to connect to the server. Please check your internet connection and try again.',
            [{ text: 'OK' }]
          );
        } else {
          Alert.alert('Error', error.message, [{ text: 'OK' }]);
        }
      } else {
        Alert.alert('Error', ERROR_MESSAGES.SERVER, [{ text: 'OK' }]);
      }
    } finally {
      setLoading(false);
    }
  }

  //check if credentials already exist
  const checkLogin = async () => {
    const storedEmail = await SecureStore.getItemAsync("garmin_email");
    const storedPassword = await SecureStore.getItemAsync("garmin_password");
    
    
    //check if credentials already exist
    if (!storedEmail || !storedPassword) {
      
      setGarminModalVisible(true);
    } 
    else {
      
      fetchGarminData(storedEmail, storedPassword);
    }
  }

  //login with new credentials
  const handleLogin = async () => {
    await SecureStore.setItemAsync("garmin_email", email);
    await SecureStore.setItemAsync("garmin_password", password);
    setGarminModalVisible(false);
    fetchGarminData(email, password);
  }

  // Add this function to check if the survey was submitted today
  const checkSurveyDate = useCallback(async () => {
    try {
      // Get stored last survey date from AsyncStorage
      const storedDate = await AsyncStorage.getItem('lastSurveyDate');
      
      // Update state with stored date
      if (storedDate) {
        setLastSurveyDate(storedDate);
      }
      
      // Get today's date in YYYY-MM-DD format
      const today = new Date().toISOString().split('T')[0];
      
      // If stored date is not today, reset the survey submitted state
      if (storedDate !== today) {
        setSurveySubmitted(false);
      } else {
        setSurveySubmitted(true);
      }
    } catch (error) {
      console.error('Error checking survey date:', error);
    }
  }, []);

  // Add this to the existing useEffect for app initialization
  useEffect(() => {
    initializeApp();
    checkSurveyDate(); // Check survey date on app load
    
    // Set up notifications
    const setupNotifications = async () => {
      // Request permissions for notifications
      const hasPermission = await requestNotificationPermissions();
      
      if (hasPermission) {
        // Schedule daily reminder at 9 AM
        await scheduleDailySurveyReminder();
      }
    }
    
    setupNotifications().catch(error => {
      console.error('Failed to set up notifications:', error);
    });
    
    // Also check when app comes to foreground
    const subscription = AppState.addEventListener('change', (nextAppState) => {
      if (nextAppState === 'active') {
        checkSurveyDate();
      }
    });
    
    return () => {
      subscription.remove();
    }
  }, [initializeApp, checkSurveyDate]);

  useEffect(() => {
    if (dataSource && !isInitialized) {
      
      initializeApp();
    }
  }, [dataSource]);

  const initializeApp = async () => {
    setLoading(true);
    try {
      if (await SecureStore.getItemAsync('garmin_email') && await SecureStore.getItemAsync('garmin_password')) {
        setDataSource('garmin');
      }
      else {
        setDataSource('apple');
      }

      if (dataSource === 'apple' && Platform.OS === 'ios') {
        
        
        
        
        // Check platform first
        if (Platform.OS !== 'ios') {
          
        setHealthKitAvailable(false);
        return;
      }

      const permissions = {
        permissions: {
          read: [
              'HeartRateVariability',
              'HeartRate',
              'Steps',
              'SleepAnalysis',
              'ActiveEnergyBurned',
              'DistanceWalkingRunning',
              'Workout',
              'Vo2Max',
              'MindfulSession',
              'DateOfBirth',
              'BiologicalSex',
              'Height',
              'Weight'
            ],
            write: [],
          },
        }

        try {
          // First check if HealthKit is available on the device
          
          const isAvailable = await new Promise((resolve) => {
            if (typeof AppleHealthKit.isAvailable !== 'function') {
              console.error('isAvailable method not found on AppleHealthKit');
                            resolve(false);
              return;
            }
            
            AppleHealthKit.isAvailable((error: string, result: boolean) => {
              if (error) {
                console.error('Error checking HealthKit availability:', error);
                resolve(false);
                return;
              }
              
              resolve(result);
            });
          });

          if (!isAvailable) {
            
            setHealthKitAvailable(false);
            Alert.alert(
              'HealthKit Not Available',
              'Please check:\n\n1. You are using an iOS device\n2. Health app is installed\n3. Your device supports HealthKit\n4. You have granted permissions in Settings',
              [{ text: 'OK' }]
            );
            return;
          }

          // Set HealthKit as available since we confirmed it is
          await new Promise<void>((resolve) => {
            setHealthKitAvailable(true);
            // Use a short timeout to ensure state is updated
            setTimeout(resolve, 0);
          });

          
          // Then initialize HealthKit
      await new Promise<void>((resolve, reject) => {
            if (typeof AppleHealthKit.initHealthKit !== 'function') {
              console.error('initHealthKit method not found on AppleHealthKit');
                            setHealthKitAvailable(false);
              reject(new Error('HealthKit initialization method not available'));
              return;
            }

        AppleHealthKit.initHealthKit(permissions, (error: string) => {
          if (error) {
            console.error('Error initializing HealthKit:', error);
            setHealthKitAvailable(false);
            reject(new Error(error));
          } else {
            
            resolve();
          }
        });
      });

          // After successful initialization, check permissions
          
          await new Promise<void>((resolve, reject) => {
            if (typeof AppleHealthKit.getAuthStatus !== 'function') {
              console.error('getAuthStatus method not found on AppleHealthKit');
              setHealthKitAvailable(false);
              reject(new Error('HealthKit auth status method not available'));
      return;
    }

            AppleHealthKit.getAuthStatus(permissions, (error: string, result: any) => {
              if (error) {
                console.error('Error checking HealthKit permissions:', error);
                setHealthKitAvailable(false);
                reject(error);
              } else {
                                if (result.permissions.read) {
                  
                  // Use setTimeout to ensure state is updated before fetching
                  setTimeout(() => {
                    
                    fetchHRVData();
                  }, 100);
                } else {
                  
                  setHealthKitAvailable(false);
                  Alert.alert(
                    'Permissions Required',
                    'Please open your device Settings > Privacy > Health and grant all permissions for this app.',
                    [{ text: 'OK' }]
                  );
                }
                resolve();
              }
        });
      });

    } catch (error) {
          console.error('HealthKit setup error:', error);
          setHealthKitAvailable(false);
          Alert.alert(
            'HealthKit Error',
            'Error setting up HealthKit. Please ensure:\n\n1. Health app is installed\n2. Permissions are granted in Settings\n3. Your device supports HealthKit',
            [{ text: 'OK' }]
          );
        }
      } else if (dataSource === 'garmin') {
        await checkLogin();
        }
        
        setIsInitialized(true);
      } catch (error) {
        console.error('Initialization error:', error);
      setHealthKitAvailable(false);
        setInitError(error instanceof Error ? error.message : ERROR_MESSAGES.INIT);
      } finally {
        setLoading(false);
      }
    }

    // Update the handler functions to use the new modal system
    const handleSourceChange = async (newSource: 'apple' | 'garmin') => {
      
      
      setDataSource(newSource);
      
      if (newSource === 'garmin') {
        openModal('garmin');
      } else if (modalManager.activeModal === 'garmin') {
        // If we're switching away from garmin, close the modal
        closeModal('garmin');
      }
    }

    // Use the openModal functions we created earlier
   

    // Helper function to check Garmin credentials
    const checkGarminCredentials = async () => {
      const storedEmail = await SecureStore.getItemAsync("garmin_email");
      const storedPassword = await SecureStore.getItemAsync("garmin_password");
      
      
      if (storedEmail && storedPassword) {
        
        setGarminModalVisible(false);
        await fetchGarminData(storedEmail, storedPassword);
      }
    }
    
    // Helper function to update data source state
    const updateDataSourceState = (newSource: 'apple' | 'garmin') => {
      // Capture existing data before clearing
      const previousData = {...garminData}
      
      // If switching from Apple to Garmin, preserve activity data
      if (dataSource === 'apple' && newSource === 'garmin' && previousData.activity) {
        
        
        // Clear existing data but preserve activity metrics
        setGarminData({
          stress: null,
          hrv: null,
          sleep: null,
          activity: {
            // Keep existing activity values if available, otherwise use defaults
            steps: previousData.activity.steps || 0,
            calories_burned: previousData.activity.calories_burned || 0,
            active_minutes: previousData.activity.active_minutes || 0,
            distance_km: previousData.activity.distance_km || 0,
            floors_climbed: previousData.activity.floors_climbed || 0,
            active_time_seconds: previousData.activity.active_time_seconds || 0,
            date: new Date().toISOString().split('T')[0],
            vo2_max: previousData.activity.vo2_max || 0,
            vo2_max_status: previousData.activity.vo2_max_status || 'N/A',
            vo2_max_date: previousData.activity.vo2_max_date || '',
            daily_activities: previousData.activity.daily_activities || [],
            mindful_minutes: previousData.activity.mindful_minutes || 0
          },
          heart_rate: null
        });
      } else {
        // Normal reset for other switches
        setGarminData({
          stress: null,
          hrv: null,
          sleep: null,
          activity: {
            steps: 0,
            calories_burned: 0,
            active_minutes: 0,
            distance_km: 0,
            floors_climbed: 0,
            active_time_seconds: 0,
            date: new Date().toISOString().split('T')[0],
            vo2_max: 0,
            vo2_max_status: 'N/A',
            vo2_max_date: '',
            daily_activities: [],
            mindful_minutes: 0
          },
          heart_rate: null
        });
      }
    
      // Update data source
      setDataSource(newSource);
    }
    
    // Modify the handlePssButtonPress function to check if any modal is already open
    const handlePssButtonPress = () => {
      if (isModalTransitioning) {
        
        return;
      }

      setIsModalTransitioning(true);
      
      try {
        // Only proceed if no other modal is currently visible
        if (garminModalVisible) {
          setGarminModalVisible(false);
          // Wait for the current modal to close completely before opening a new one
          setTimeout(() => {
            setPssModalVisible(true);
          }, 300);
        } else if (personalInfoModalVisible) {
          setPersonalInfoModalVisible(false);
          setTimeout(() => {
            setPssModalVisible(true);
          }, 300);
        } else {
          // No other modal is open, can show directly
          setPssModalVisible(true);
        }
      } finally {
        // Reset the transitioning flag after a delay
        setTimeout(() => {
          setIsModalTransitioning(false);
        }, 500);
      }
    }

    // Modify the handlePersonalInfoButtonPress function similarly
    const handlePersonalInfoButtonPress = () => {
      if (isModalTransitioning) {
        
        return;
      }

      try {
        // Only proceed if no other modal is currently visible
        if (garminModalVisible) {
          setGarminModalVisible(false);
          // Wait for the current modal to close completely before opening a new one
          setTimeout(() => {
            setPersonalInfoModalVisible(true);
          }, 300);
        } else if (pssModalVisible) {
          setPssModalVisible(false);
          setTimeout(() => {
            setPersonalInfoModalVisible(true);
          }, 300);
        } else {
          // No other modal is open, can show directly
          setPersonalInfoModalVisible(true);
        }
      } finally {
        // Reset the transitioning flag after a delay
        setTimeout(() => {
          setIsModalTransitioning(false);
        }, 500);
      }
    }

  // Data Source Selection Modal
  const DataSourceSelectionModal = () => (
    <Modal
      animationType="slide"
      transparent={true}
      visible={sourceSelectionVisible}
      onRequestClose={() => {}}
    >
      <View style={styles.modalContainer}>
        <View style={styles.modalContent}>
          <Text style={styles.modalTitle}>W√§hlen Sie Ihre Datenquelle</Text>
          <View style={styles.sourceButtonContainer}>
            {Platform.OS === 'ios' && (
              <TouchableOpacity
                style={[styles.button, styles.appleButton]}
                onPress={() => {
                  setDataSource('apple');
                  setSourceSelectionVisible(false);
                }}
              >
                <Text style={styles.buttonText}>Apple Watch</Text>
              </TouchableOpacity>
            )}
            <TouchableOpacity
              style={[styles.button, styles.garminButton]}
              onPress={() => {
                setSourceSelectionVisible(false);
                handleSourceChange('garmin');
              }}
            >
              <Text style={styles.buttonText}>Garmin</Text>
            </TouchableOpacity>
          </View>
        </View>
      </View>
    </Modal>
  );

  if (!isInitialized) {
    return (
      <View style={styles.container}>
        <ActivityIndicator size="large" color="#0000ff" />
        {initError && (
          <Text style={styles.errorText}>{initError}</Text>
        )}
      </View>
    );
  }

 

  const handleResponseChange = (value: number, index: number) => {
    const newResponses = [...responses];
    newResponses[index] = value;
    setResponses(newResponses);
  }

  const submitSurvey = async () => {
    if (!db) {
      Alert.alert('Error', 'Database connection not available');
      return;
    }
    
    try {
      if (responses.some(response => response === 0)) {
        Alert.alert("Error", "Please answer all questions");
        return;
      }

      // Get or create device ID
      const deviceId = await getOrCreateDeviceId();
      
      // Get today's date in YYYY-MM-DD format
      const today = new Date().toISOString().split('T')[0];
      
      // Prepare data
      const data = {
        responses,
        otherText: responses[3] === 5 ? otherText : "",
        dailySurveyResponses, // Include the daily survey responses
        timestamp: new Date(),
        deviceId,
        date: today // Store the date with the submission
      }
      
      
      // Submit to Firestore
      const pssCollection = collection(db, "pss_responses");
      await addDoc(pssCollection, data);
      
      // Reset and close
      setResponses([0, 0, 0, 0]);
      setOtherText("");
      
      // Reset daily survey responses
      setDailySurveyResponses({
        seasonal_allergies: false,
        sick: false,
        alcohol: false,
        smoking: false,
        caffeine: false,
        bright_lights: false,
        phone_in_bed: false,
        processed_food: false,
        late_meal: false,
        water_3l: false,
        morning_sunlight: false,
        meditation: false,
        exercise: false,
        exercise_type: "",
        exercise_duration: "",
        met_friends: false,
        journaling: false,
        reading: false,
        relaxation: false,
        relaxation_duration: "",
        relaxation_meditation: false,
        relaxation_breathing: false,
        relaxation_journaling: false,
        relaxation_music: false,
        relaxation_other: false,
        relaxation_other_text: "",
        emotion_happiness: false,
        emotion_anxiety: false,
        emotion_sadness: false,
        emotion_anger: false,
        emotion_relaxation: false
      });
      
      setPssModalVisible(false);
      setSurveySubmitted(true); // Mark survey as submitted
      setLastSurveyDate(today); // Store the submission date in state
      
      // Also persist to AsyncStorage
      await AsyncStorage.setItem('lastSurveyDate', today);

      Alert.alert("Success", "Survey submitted successfully!");
    } catch (error) {
      console.error("Error sending survey:", error);
      Alert.alert("Error", "Failed to send survey. Please try again later.");
    }
  }

  const submitPersonalInfo = async (dataToSubmit = personalInfo) => {
    
    
    

    const firestore = db as Firestore;

    try {
      // Enhanced validation with more debugging information
      if (!dataToSubmit.age || dataToSubmit.age === null || dataToSubmit.age === undefined) {
        console.error("Age validation failed. Age is:", dataToSubmit.age);
        Alert.alert("Error", "Please fill in at least age and gender");
        return false;
      }
      
      if (!dataToSubmit.gender || dataToSubmit.gender === "" || dataToSubmit.gender === null) {
        console.error("Gender validation failed. Gender is:", dataToSubmit.gender);
        Alert.alert("Error", "Please fill in at least age and gender");
        return false;
      }

      // Get or create device ID
      const currentDeviceId = await getOrCreateDeviceId();

      // Prepare data object with explicit type conversions where needed
      const finalData = {
        ...dataToSubmit,
        age: typeof dataToSubmit.age === 'string' ? parseInt(dataToSubmit.age, 10) : dataToSubmit.age,
        gender: String(dataToSubmit.gender),
        timestamp: new Date(),
        deviceId: currentDeviceId
      }
      
      

      const personalInfoCollection = collection(firestore, "personal_info");
      await addDoc(personalInfoCollection, finalData);

      Alert.alert("Success", "Personal information saved successfully!");
      
      // Only reset the form data if we're submitting the main state
      if (dataToSubmit === personalInfo) {
        setPersonalInfo({
          age: null as number | null,
          gender: "" as string,
          height: null as number | null,
          weight: null as number | null,
          fitness_level: null as number | null,
          stress_level: null as number | null,
          sleep_quality: null as number | null,
          pre_existing_conditions: "" as string,
          allergies: "" as string,
          smoker: "" as string,
          alcohol_consumption: "" as string,
          firstname: "" as string,
          lastname: "" as string,
          marijuana_consumption: "" as string,
          diet_type: "" as string,
          cold_showers: "" as string,
          meditation: "" as string,
          sauna_use: "" as string,
          sleep_medication: "" as string,
          blue_light_glasses: "" as string,
          intermittent_fasting: "" as string,
          sleep_mask: "" as string,
          seasonal_allergies: "" as string,
          caffeine_consumption: "" as string,
        });
      }
      
      setPersonalInfoSubmitted(true); // Mark as submitted
      
      // Return success - modal visibility handled by caller
      return true;
    } catch (error) {
      console.error("Error saving personal information:", error);
      Alert.alert("Error", "There was a problem saving the data.");
      return false;
    }
  }

  const formatDuration = (seconds: number) => {
    if (!seconds) return 'N/A';
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    return `${hours}h ${minutes}m`;
  }

  // Update the autoFillPersonalInfo function to return data instead of updating state directly
  const autoFillPersonalInfo = async () => {
    
    
    try {
      // Create a copy of the current personalInfo to update
      const updatedInfo = { ...personalInfo }
      let updatesMade = false;
      
      if (dataSource === 'garmin') {
        
        
        // Check if we have Garmin data
        if (garminData && Object.keys(garminData).length > 0) {
          // ... existing Garmin data filling logic ...
        }
      } else if (dataSource === 'apple') {
        // ... existing Apple Health data filling logic ...
      }
      
      // Return the updated info rather than setting state
      return updatedInfo;
    } catch (error) {
      console.error("Error in autoFillPersonalInfo:", error);
      throw error;
    }
  }

  // Helper function to format numeric values safely
  const formatNumber = (value: any): string => {
    const num = parseFloat(value);
    return !isNaN(num) ? num.toString() : "";
  }

  // Update the PersonalInfoModal to handle NaN values
  const PersonalInfoModal = () => {
    const [localModalVisible, setLocalModalVisible] = useState(true);
    const [isAutoFilling, setIsAutoFilling] = useState(false);
    
    // Gender selection - moved to top level for better visibility
    const [showGenderOptions, setShowGenderOptions] = useState(false);
    const genderOptions = [
      { label: "Male", value: "male" },
      { label: "Female", value: "female" },
      { label: "Diverse", value: "diverse" }
    ];
    
    // Smoker selection
    const [showSmokerOptions, setShowSmokerOptions] = useState(false);
    const smokerOptions = [
      { label: "Yes", value: "yes" },
      { label: "No", value: "no" },
      { label: "Occasional", value: "occasional" }
    ];
    
    // Alcohol consumption selection
    const [showAlcoholOptions, setShowAlcoholOptions] = useState(false);
    const alcoholOptions = [
      { label: "Never", value: "never" },
      { label: "Rarely", value: "rarely" },
      { label: "Occasionally", value: "occasionally" },
      { label: "Regularly", value: "regularly" },
      { label: "Daily", value: "daily" }
    ];

    // Marijuana consumption selection
    const [showMarijuanaOptions, setShowMarijuanaOptions] = useState(false);
    const marijuanaOptions = [
      { label: "Yes", value: "yes" },
      { label: "No", value: "no" },
      { label: "Occasional", value: "occasional" }
    ];

    // Diet type selection
    const [showDietOptions, setShowDietOptions] = useState(false);
    const dietOptions = [
      { label: "Omnivore", value: "omnivore" },
      { label: "Vegetarian", value: "vegetarian" },
      { label: "Vegan", value: "vegan" },
      { label: "Pescatarian", value: "pescatarian" },
      { label: "Keto", value: "keto" },
      { label: "Paleo", value: "paleo" },
      { label: "Low-carb", value: "low-carb" },
      { label: "Mediterranean", value: "mediterranean" },
      { label: "Other", value: "other" }
    ];

    // Yes/No options for various selections
    const yesNoOptions = [
      { label: "Yes", value: "yes" },
      { label: "No", value: "no" }
    ];

    // Options visibility states for new fields
    const [showColdShowerOptions, setShowColdShowerOptions] = useState(false);
    const [showMeditationOptions, setShowMeditationOptions] = useState(false);
    const [showSaunaOptions, setShowSaunaOptions] = useState(false);
    const [showSleepMedicationOptions, setShowSleepMedicationOptions] = useState(false);
    const [showBlueLightGlassesOptions, setShowBlueLightGlassesOptions] = useState(false);
    const [showIntermittentFastingOptions, setShowIntermittentFastingOptions] = useState(false);
    const [showSleepMaskOptions, setShowSleepMaskOptions] = useState(false);
    const [showSeasonalAllergiesOptions, setShowSeasonalAllergiesOptions] = useState(false);
    const [showCaffeineConsumptionOptions, setShowCaffeineConsumptionOptions] = useState(false);
    
    // Store local copies of relevant fields with direct initialization
    const [localPersonalInfo, setLocalPersonalInfo] = useState(() => {
      console.log("üîÑ Initializing localPersonalInfo:", {
        fitness_level: personalInfo.fitness_level,
        stress_level: personalInfo.stress_level,
        sleep_quality: personalInfo.sleep_quality
      });
      return personalInfo;
    });
    
    // Update local copy when personalInfo changes from outside
    useEffect(() => {
      console.log("üîÑ personalInfo changed, updating localPersonalInfo:", {
        fitness_level: personalInfo.fitness_level,
        stress_level: personalInfo.stress_level,
        sleep_quality: personalInfo.sleep_quality
      });
      setLocalPersonalInfo({...personalInfo});
    }, [personalInfo]);
    
    // Separate effect specifically for gender changes
    useEffect(() => {
      
    }, [localPersonalInfo.gender]);
    
    // Separate state just for gender to avoid re-render issues
    const [selectedGender, setSelectedGender] = useState(localPersonalInfo.gender || null);
    const [selectedSmoker, setSelectedSmoker] = useState(localPersonalInfo.smoker || null);
    const [selectedAlcohol, setSelectedAlcohol] = useState(localPersonalInfo.alcohol_consumption || null);
    
    // Keep selectedGender in sync with localPersonalInfo
    useEffect(() => {
      if (localPersonalInfo.gender !== selectedGender) {
        
        setSelectedGender(localPersonalInfo.gender || null);
      }
      
      if (localPersonalInfo.smoker !== selectedSmoker) {
        
        setSelectedSmoker(localPersonalInfo.smoker || null);
      }
      
      if (localPersonalInfo.alcohol_consumption !== selectedAlcohol) {
        
        setSelectedAlcohol(localPersonalInfo.alcohol_consumption || null);
      }
    }, [localPersonalInfo, selectedGender, selectedSmoker, selectedAlcohol]);
    
    // Handle gender selection
    const handleGenderSelect = (value) => {
      
      setSelectedGender(value);
      setLocalPersonalInfo(prev => ({...prev, gender: value}));
      setShowGenderOptions(false);
    }
    
    // Handle smoker selection
    const handleSmokerSelect = (value) => {
      
      setSelectedSmoker(value);
      setLocalPersonalInfo(prev => ({...prev, smoker: value}));
      setShowSmokerOptions(false);
    }
    
    // Handle alcohol selection
    const handleAlcoholSelect = (value) => {
      
      setSelectedAlcohol(value);
      setLocalPersonalInfo(prev => ({...prev, alcohol_consumption: value}));
      setShowAlcoholOptions(false);
    }

    const handleCloseModal = () => {
      
      
      // Directly close the modal by updating both local and parent state
      setLocalModalVisible(false);
      setPersonalInfoModalVisible(false);
      
      // Ensure the modal manager is updated
      if (modalManager && typeof closeModal === 'function') {
        closeModal('personal');
      } else {
        
        setActiveModal(null);
      }
      
      
    }

    const handleSubmit = async () => {
      
      
      
      // Basic validation
      if (!localPersonalInfo.age || !localPersonalInfo.gender) {
        
        Alert.alert('Error', 'Please enter at least age and gender.');
        return; // Return early without closing the modal
      }

      // Log all values for debugging
      
      
      
      
      try {
        // Submit the data directly with local state, don't update global state first
        const success = await submitPersonalInfo(localPersonalInfo);
        
        // Only update global state and close modal if submission was successful
        if (success) {
          
          setPersonalInfo({...localPersonalInfo});
          
          // Close the modal with proper animation
          handleCloseModal();
        } else {
          
        }
      } catch (error) {
        console.error("Error during submission:", error);
        Alert.alert('Error', 'There was a problem saving the data. Please try again.');
      }
    }

    // Fix the auto-fill function to correctly access Garmin data structure
    const handleAutoFill = async () => {
      // Prevent multiple auto-fill attempts
      if (isAutoFilling) return;
      
      // Set loading state
      setIsAutoFilling(true);
      console.log("üîÑ Starting auto-fill process with source:", dataSource);
      
      try {
        if (dataSource === 'garmin') {
          // Existing Garmin code...
          // ... existing code ...
        } else if (dataSource === 'apple' && healthKitAvailable) {
          console.log("üçé Using Apple HealthKit for auto-fill");
          
          // Create a copy of the local state to work with
          const updatedInfo = { ...localPersonalInfo }
          let updatesMade = false;
          
          try {
            // Get 3 months of health data for calculating metrics
            const threeMonthsAgo = new Date();
            threeMonthsAgo.setMonth(threeMonthsAgo.getMonth() - 3);
            
            const options = {
              startDate: threeMonthsAgo.toISOString(),
              endDate: new Date().toISOString(),
            }
            
            console.log("üìÜ Date range:", threeMonthsAgo.toISOString(), "to", new Date().toISOString());
            
            // First fetch basic user profile information
            console.log("üë§ Fetching user data from HealthKit...");
            
            // 1. Get biological sex
            try {
              const biologicalSex = await new Promise<any>((resolve, reject) => {
                if (typeof AppleHealthKit.getBiologicalSex !== 'function') {
                  console.error("‚ùå getBiologicalSex function not available");
                  resolve(null);
                  return;
                }
                
                AppleHealthKit.getBiologicalSex({}, (err, result) => {
                  if (err) {
                    console.error('‚ùå Error fetching biological sex:', err);
                    resolve(null);
                  } else {
                    console.log(`üë§ Biological sex data:`, result);
                    resolve(result);
                  }
                });
              });
              
              if (biologicalSex && biologicalSex.value) {
                // Map HealthKit sex values to our format
                let genderValue = "";
                if (biologicalSex.value === 'male') {
                  genderValue = "male";
                } else if (biologicalSex.value === 'female') {
                  genderValue = "female";
                } else if (biologicalSex.value === 'other') {
                  genderValue = "diverse";
                }
                
                if (genderValue) {
                  console.log(`üë§ Setting gender to: ${genderValue}`);
                  updatedInfo.gender = genderValue;
                  updatesMade = true;
                  
                  // Update the selected gender state to trigger UI update
                  setSelectedGender(genderValue);
                }
              }
            } catch (error) {
              console.error("‚ùå Error getting biological sex:", error);
            }
            
            // 2. Get date of birth for age calculation
            try {
              const dateOfBirth = await new Promise<any>((resolve, reject) => {
                if (typeof AppleHealthKit.getDateOfBirth !== 'function') {
                  console.error("‚ùå getDateOfBirth function not available");
                  resolve(null);
                  return;
                }
                
                AppleHealthKit.getDateOfBirth({}, (err, result) => {
                  if (err) {
                    console.error('‚ùå Error fetching date of birth:', err);
                    resolve(null);
                  } else {
                    console.log(`üë§ Date of birth data:`, result);
                    resolve(result);
                  }
                });
              });
              
              if (dateOfBirth && dateOfBirth.value) {
                const dob = new Date(dateOfBirth.value);
                const today = new Date();
                let age = today.getFullYear() - dob.getFullYear();
                
                // Adjust age if birthday hasn't occurred yet this year
                const m = today.getMonth() - dob.getMonth();
                if (m < 0 || (m === 0 && today.getDate() < dob.getDate())) {
                  age--;
                }
                
                console.log(`üë§ Calculated age: ${age}`);
                updatedInfo.age = age;
                updatesMade = true;
              }
            } catch (error) {
              console.error("‚ùå Error getting date of birth:", error);
            }
            
            // 3. Get latest height
            try {
              const heightData = await new Promise<any>((resolve, reject) => {
                if (typeof AppleHealthKit.getHeightSamples !== 'function') {
                  console.error("‚ùå getHeightSamples function not available");
                  resolve(null);
                  return;
                }
                
                AppleHealthKit.getHeightSamples({
                  unit: 'cm',
                  ascending: false,
                  limit: 1,
                  startDate: options.startDate, // Add start date
                  endDate: options.endDate      // Add end date
                }, (err, results) => {
                  if (err) {
                    console.error('‚ùå Error fetching height data:', err);
                    resolve(null);
                  } else if (Array.isArray(results) && results.length > 0) {
                    console.log(`üë§ Height data:`, results[0]);
                    resolve(results[0]);
                  } else {
                    console.log("‚ùå No height data available");
                    resolve(null);
                  }
                });
              });
              
              if (heightData && heightData.value) {
                const height = Math.round(heightData.value);
                console.log(`üë§ Setting height to: ${height} cm`);
                updatedInfo.height = height;
                updatesMade = true;
              }
            } catch (error) {
              console.error("‚ùå Error getting height:", error);
            }
            
            // 4. Get latest weight
            try {
              const weightData = await new Promise<any>((resolve, reject) => {
                if (typeof AppleHealthKit.getWeightSamples !== 'function') {
                  console.error("‚ùå getWeightSamples function not available");
                  resolve(null);
                  return;
                }
                
                AppleHealthKit.getWeightSamples({
                  unit: 'kg',
                  ascending: false,
                  limit: 1,
                  startDate: options.startDate, // Add start date
                  endDate: options.endDate      // Add end date
                }, (err, results) => {
                  if (err) {
                    console.error('‚ùå Error fetching weight data:', err);
                    resolve(null);
                  } else if (Array.isArray(results) && results.length > 0) {
                    console.log(`üë§ Weight data:`, results[0]);
                    resolve(results[0]);
                  } else {
                    console.log("‚ùå No weight data available");
                    resolve(null);
                  }
                });
              });
              
              if (weightData && weightData.value) {
                const weight = Math.round(weightData.value);
                console.log(`üë§ Setting weight to: ${weight} kg`);
                updatedInfo.weight = weight;
                updatesMade = true;
              }
            } catch (error) {
              console.error("‚ùå Error getting weight:", error);
            }

            // Fetch sleep data for last 3 months
            const sleepSamples = await new Promise<any[]>((resolve, reject) => {
              if (typeof AppleHealthKit.getSleepSamples !== 'function') {
                console.error("‚ùå getSleepSamples function not available");
                resolve([]);
                return;
              }
              
              console.log("üí§ Fetching sleep samples...");
              
              AppleHealthKit.getSleepSamples(
                {
                  ...options,
                  type: 'SleepAnalysis',
                  includeStages: true
                },
                (err: string | null, results: any[]) => {
                  if (err) {
                    console.error('‚ùå Error fetching sleep:', err);
                    resolve([]);
                  } else if (Array.isArray(results)) {
                    console.log(`üí§ Got ${results.length} sleep samples`);
                    if (results.length > 0) {
                      // Log first and last day
                      const firstDay = new Date(results[0].startDate).toISOString().split('T')[0];
                      const lastDay = new Date(results[results.length-1].endDate).toISOString().split('T')[0];
                      console.log(`üí§ Sleep data from ${firstDay} to ${lastDay}`);
                      
                      // Count unique days with sleep data
                      const uniqueDays = new Set(
                        results.map(item => new Date(item.startDate).toISOString().split('T')[0])
                      );
                      console.log(`üí§ Data from ${uniqueDays.size} unique days`);
                    }
                    resolve(results);
                  } else {
                    console.error("‚ùå Sleep samples not an array:", results);
                    resolve([]);
                  }
                }
              );
            });
            
            // Initialize with proper structures
            let vo2MaxResults = { value: 0 }
            let workoutResults = { activeMinutes: 0, activities: [] }
            let distanceResult = { value: 0 }
            let hrvData = [];
            let totalMindfulMinutes = 0;
            
            // Fetch all required health data
            try {
              // 1. Fetch VO2 max data for fitness level calculation
              console.log("ü´Å Fetching VO2 max data...");
              vo2MaxResults = await new Promise<any>((resolve, reject) => {
                if (typeof AppleHealthKit.getVo2MaxSamples !== 'function') {
                  console.error("‚ùå getVo2MaxSamples function not available");
                  resolve({ value: 0 });
                  return;
                }
                
                AppleHealthKit.getVo2MaxSamples(
                  {
                    unit: 'mL/(kg*min)',
                    ascending: false,
                    limit: 10,
                    startDate: options.startDate,
                    endDate: options.endDate
                  },
                  (err, results) => {
                    if (err) {
                      console.error('‚ùå Error fetching VO2 max:', err);
                      resolve({ value: 0 });
                    } else if (Array.isArray(results) && results.length > 0) {
                      console.log(`ü´Å Got ${results.length} VO2 max samples`);
                      // Get the most recent result
                      const latestResult = results[0];
                      console.log(`ü´Å Latest VO2 max: ${latestResult.value}`);
                      resolve(latestResult);
                    } else {
                      console.log("‚ùå No VO2 max data available");
                      resolve({ value: 0 });
                    }
                  }
                );
              });
              
              // 2. Fetch workout data
              console.log("üèÉ‚Äç‚ôÇÔ∏è Fetching workout data...");
              const workoutData = await new Promise<any>((resolve, reject) => {
                if (typeof AppleHealthKit.getAnchoredWorkouts !== 'function') {
                  console.error("‚ùå getAnchoredWorkouts function not available");
                  resolve({ activeMinutes: 0, activities: [] });
                  return;
                }
                
                AppleHealthKit.getAnchoredWorkouts(
                  {
                    startDate: options.startDate,
                    endDate: options.endDate,
                    type: 'Workout'
                  },
                  (err, results) => {
                    if (err) {
                      console.error('‚ùå Error fetching workouts:', err);
                      resolve({ activeMinutes: 0, activities: [] });
                    } else if (results && Array.isArray(results.data) && results.data.length > 0) {
                      console.log(`üèÉ‚Äç‚ôÇÔ∏è Got ${results.data.length} workouts`);
                      
                      // Convert workout data to activities format
                      const activities = results.data.map((workout: any) => ({
                        type: workout.activityName || 'Unknown Activity',
                        duration_minutes: Math.round((workout.duration || 0) / 60)
                      }));
                      
                      // Calculate total active minutes
                      const totalActiveMinutes = activities.reduce((total: number, activity: any) => 
                        total + activity.duration_minutes, 0);
                      
                      console.log(`üèÉ‚Äç‚ôÇÔ∏è Total active minutes: ${totalActiveMinutes}`);
                      
                      resolve({
                        activeMinutes: totalActiveMinutes,
                        activities: activities
                      });
                    } else {
                      console.log("‚ùå No workout data available");
                      resolve({ activeMinutes: 0, activities: [] });
                    }
                  }
                );
              });
              workoutResults = workoutData;
              
              // 3. Fetch distance data
              console.log("üèÉ‚Äç‚ôÇÔ∏è Fetching distance data...");
              distanceResult = await new Promise<any>((resolve, reject) => {
                if (typeof AppleHealthKit.getDailyDistanceWalkingRunningSamples !== 'function') {
                  console.error("‚ùå getDailyDistanceWalkingRunningSamples function not available");
                  resolve({ value: 0 });
                  return;
                }
                
                AppleHealthKit.getDailyDistanceWalkingRunningSamples(
                  {
                    startDate: options.startDate,
                    endDate: options.endDate,
                    unit: 'km',
                    ascending: false
                  },
                  (err, results) => {
                    if (err) {
                      console.error('‚ùå Error fetching distance samples:', err);
                      resolve({ value: 0 });
                    } else if (Array.isArray(results) && results.length > 0) {
                      // Sum up all distance values in the array
                      const totalDistance = results.reduce((sum, item) => 
                        sum + (item.value || 0), 0) / 1000; // Convert from meters to kilometers
                      console.log(`üèÉ‚Äç‚ôÇÔ∏è Total distance from ${results.length} daily samples: ${totalDistance} km`);
                      resolve({ value: totalDistance });
                    } else {
                      console.log("‚ùå No distance data available in the specified period");
                      resolve({ value: 0 });
                    }
                  }
                );
              });
              
              // 4. Fetch HRV data
              console.log("‚ù§Ô∏è Fetching HRV data...");
              hrvData = await new Promise<any[]>((resolve, reject) => {
                if (typeof AppleHealthKit.getHeartRateVariabilitySamples !== 'function') {
                  console.error("‚ùå getHeartRateVariabilitySamples function not available");
                  resolve([]);
                  return;
                }
                
                AppleHealthKit.getHeartRateVariabilitySamples(
                  {
                    startDate: options.startDate,
                    endDate: options.endDate
                  },
                  (err, results) => {
                    if (err) {
                      console.error('‚ùå Error fetching HRV data:', err);
                      resolve([]);
                    } else if (Array.isArray(results) && results.length > 0) {
                      console.log(`‚ù§Ô∏è Got ${results.length} HRV samples`);
                      resolve(results);
                    } else {
                      console.log("‚ùå No HRV data available");
                      resolve([]);
                    }
                  }
                );
              });
              
              // 5. Fetch mindfulness data
              console.log("üßò‚Äç‚ôÇÔ∏è Fetching mindfulness data...");
              const mindfulnessData = await new Promise<any[]>((resolve, reject) => {
                if (typeof AppleHealthKit.getMindfulSession !== 'function') {
                  console.error("‚ùå getMindfulSession function not available");
                  resolve([]);
                  return;
                }
                
                AppleHealthKit.getMindfulSession(
                  {
                    startDate: options.startDate,
                    endDate: options.endDate,
                    type: 'MindfulSession'
                  },
                  (err, results) => {
                    if (err) {
                      console.error('‚ùå Error fetching mindfulness data:', err);
                      resolve([]);
                    } else if (Array.isArray(results) && results.length > 0) {
                      console.log(`üßò‚Äç‚ôÇÔ∏è Got ${results.length} mindfulness sessions`);
                      resolve(results);
                    } else {
                      console.log("‚ùå No mindfulness data available");
                      resolve([]);
                    }
                  }
                );
              });
              
              // Calculate total mindful minutes
              if (Array.isArray(mindfulnessData) && mindfulnessData.length > 0) {
                totalMindfulMinutes = mindfulnessData.reduce((total, session) => {
                  if (session.startDate && session.endDate) {
                    const startTime = new Date(session.startDate).getTime();
                    const endTime = new Date(session.endDate).getTime();
                    const durationMinutes = (endTime - startTime) / (1000 * 60);
                    return total + durationMinutes;
                  }
                  return total;
                }, 0);
                console.log(`üßò‚Äç‚ôÇÔ∏è Total mindful minutes: ${totalMindfulMinutes}`);
              }
              
              // 6. Fetch steps data
              console.log("üë£ Fetching steps data...");
              const stepsResult = await new Promise<any>((resolve, reject) => {
                if (typeof AppleHealthKit.getDailyStepCountSamples !== 'function') {
                  console.error("‚ùå getDailyStepCountSamples function not available");
                  resolve({ value: 0 });
                  return;
                }
                
                AppleHealthKit.getDailyStepCountSamples(
                  {
                    startDate: options.startDate,
                    endDate: options.endDate,
                    includeManuallyAdded: true,
                  },
                  (err, results) => {
                    if (err) {
                      console.error('‚ùå Error fetching steps:', err);
                      resolve({ value: 0 });
                    } else if (Array.isArray(results) && results.length > 0) {
                      const totalSteps = results.reduce((sum, item) => 
                        sum + (item.value || 0), 0);
                      console.log(`üë£ Total steps from ${results.length} daily samples: ${totalSteps}`);
                      resolve({ value: totalSteps });
                    } else {
                      console.log("‚ùå No steps data available in the specified period");
                      resolve({ value: 0 });
                    }
                  }
                );
              });
              
              // 7. Fetch calories data
              console.log("üî• Fetching calories data...");
              const caloriesResult = await new Promise<any>((resolve, reject) => {
                if (typeof AppleHealthKit.getActiveEnergyBurned !== 'function') {
                  console.error("‚ùå getActiveEnergyBurned function not available");
                  resolve({ value: 0 });
                  return;
                }
                
                AppleHealthKit.getActiveEnergyBurned(
                  {
                    startDate: options.startDate,
                    endDate: options.endDate,
                    includeManuallyAdded: true,
                  },
                  (err, results) => {
                    if (err) {
                      console.error('‚ùå Error fetching calories:', err);
                      resolve({ value: 0 });
                    } else if (Array.isArray(results) && results.length > 0) {
                      const totalCalories = results.reduce((sum, item) => 
                        sum + (item.value || 0), 0);
                      console.log(`üî• Total calories from ${results.length} daily samples: ${totalCalories}`);
                      resolve({ value: totalCalories });
                    } else {
                      console.log("‚ùå No calories data available in the specified period");
                      resolve({ value: 0 });
                    }
                  }
                );
              });
              
              // Log data status before calculations
              console.log("üìä Pre-calculation data check:", {
                "vo2Max": vo2MaxResults?.value || 0,
                "workouts.activeMinutes": workoutResults?.activeMinutes || 0,
                "distance.value": distanceResult?.value || 0,
                "hrvData.length": hrvData?.length || 0,
                "totalMindfulMinutes": totalMindfulMinutes || 0,
                "steps": stepsResult?.value || 0,
                "calories": caloriesResult?.value || 0
              });
            } catch (error) {
              console.error("‚ùå Error fetching health data:", error);
            }
            
            // Calculate fitness level (1-10 scale)
            const vo2MaxValue = vo2MaxResults?.value || 0;
            const fitnessLevel = calculateFitnessLevel(vo2MaxValue, workoutResults, distanceResult);
            console.log(`üìä Final fitness_level calculated: ${fitnessLevel}`);
            updatedInfo.fitness_level = fitnessLevel;
            
            // Calculate stress level (1-10 scale)
            const stressLevel = calculateStressLevel(hrvData, totalMindfulMinutes, sleepSamples);
            console.log(`üìä Final stress_level calculated: ${stressLevel}`);
            updatedInfo.stress_level = stressLevel;
            
            // Calculate sleep quality (1-10 scale)
            const sleepQuality = calculateSleepQuality(sleepSamples);
            console.log(`üìä Final sleep_quality calculated: ${sleepQuality}`);
            updatedInfo.sleep_quality = sleepQuality;
            
            // Make sure the values are not null by using the ensureHealthMetrics function
            const healthMetrics = ensureHealthMetrics({
              fitness_level: updatedInfo.fitness_level,
              stress_level: updatedInfo.stress_level,
              sleep_quality: updatedInfo.sleep_quality
            });
            
            // Apply the ensured values
            updatedInfo.fitness_level = healthMetrics.fitness_level;
            updatedInfo.stress_level = healthMetrics.stress_level;
            updatedInfo.sleep_quality = healthMetrics.sleep_quality;
            
            console.log("üîÑ Final values to be set:", {
              fitness_level: updatedInfo.fitness_level,
              stress_level: updatedInfo.stress_level,
              sleep_quality: updatedInfo.sleep_quality
            });
            
            // Update if we calculated any metrics
            if (fitnessLevel || stressLevel || sleepQuality) {
              console.log(`‚úÖ At least one metric was calculated successfully`);
              updatesMade = true;
            } else {
              console.log(`‚ö†Ô∏è No metrics could be calculated`);
            }
            
            if (updatesMade) {
              // Update LOCAL state in the modal (not global state)
              console.log("üîÑ Updating localPersonalInfo with calculated metrics");
              setLocalPersonalInfo(updatedInfo);
              
              // Force UI refresh
              console.log("üîÑ Forcing UI refresh");
              setTimeout(() => {
                // This is a trick to force re-render of inputs
                setLocalPersonalInfo(prev => ({...prev}));
              }, 100);
            } else {
              Alert.alert('Info', 'No data available for auto-fill');
            }
          } catch (error) {
            console.error("‚ùå Error in HealthKit auto-fill:", error);
            Alert.alert('Error', 'Problem querying HealthKit data: ' + (error instanceof Error ? error.message : String(error)));
          }
        } else {
          console.warn("‚ö†Ô∏è No valid data source selected or HealthKit not available");
          Alert.alert('Info', 'Please select a data source first (Apple Health or Garmin)');
        }
      } catch (error: any) {
        console.error("‚ùå Auto-fill error:", error);
        Alert.alert('Error', 'There was a problem with auto-filling: ' + error.message);
      } finally {
        // Reset loading state
        setIsAutoFilling(false);
      }
    }

    // Add a direct close handler for the Cancel button
    const handleCancel = () => {
      
      
      // Use direct approach to ensure modal closes
      setLocalModalVisible(false);
      setPersonalInfoModalVisible(false);
      
      if (typeof setActiveModal === 'function') {
        setActiveModal(null);
      }
      
      
    }

    // Handle marijuana selection
    const handleMarijuanaSelect = (value) => {
      setLocalPersonalInfo(prev => ({...prev, marijuana_consumption: value}));
      setShowMarijuanaOptions(false);
    }

    // Handle diet type selection
    const handleDietSelect = (value) => {
      setLocalPersonalInfo(prev => ({...prev, diet_type: value}));
      setShowDietOptions(false);
    }

    // Handle cold shower selection
    const handleColdShowerSelect = (value) => {
      setLocalPersonalInfo(prev => ({...prev, cold_showers: value}));
      setShowColdShowerOptions(false);
    }

    // Handle meditation selection
    const handleMeditationSelect = (value) => {
      setLocalPersonalInfo(prev => ({...prev, meditation: value}));
      setShowMeditationOptions(false);
    }

    // Handle sauna selection
    const handleSaunaSelect = (value) => {
      setLocalPersonalInfo(prev => ({...prev, sauna_use: value}));
      setShowSaunaOptions(false);
    }

    // Handle sleep medication selection
    const handleSleepMedicationSelect = (value) => {
      setLocalPersonalInfo(prev => ({...prev, sleep_medication: value}));
      setShowSleepMedicationOptions(false);
    }

    // Handle blue light glasses selection
    const handleBlueLightGlassesSelect = (value) => {
      setLocalPersonalInfo(prev => ({...prev, blue_light_glasses: value}));
      setShowBlueLightGlassesOptions(false);
    }

    // Handle intermittent fasting selection
    const handleIntermittentFastingSelect = (value) => {
      setLocalPersonalInfo(prev => ({...prev, intermittent_fasting: value}));
      setShowIntermittentFastingOptions(false);
    }

    // Handle sleep mask selection
    const handleSleepMaskSelect = (value) => {
      setLocalPersonalInfo(prev => ({...prev, sleep_mask: value}));
      setShowSleepMaskOptions(false);
    }

    // Handle seasonal allergies selection
    const handleSeasonalAllergiesSelect = (value) => {
      setLocalPersonalInfo(prev => ({...prev, seasonal_allergies: value}));
      setShowSeasonalAllergiesOptions(false);
    }

    // Handle caffeine consumption selection
    const handleCaffeineConsumptionSelect = (value) => {
      setLocalPersonalInfo(prev => ({...prev, caffeine_consumption: value}));
      setShowCaffeineConsumptionOptions(false);
    }

    return (
      <Modal
        animationType="slide"
        transparent={true}
        visible={personalInfoModalVisible && localModalVisible}
        onRequestClose={() => {
          
          setLocalModalVisible(false);
          setPersonalInfoModalVisible(false);
          if (typeof setActiveModal === 'function') {
            setActiveModal(null);
          }
        }}
      >
        <View style={styles.modalContainer}>
          <View style={[styles.modalContent, { maxHeight: '90%' }]}>
            <View style={styles.modalHeader}>
              <Text style={styles.modalTitle}>Personal Information</Text>
              <TouchableOpacity onPress={handleCloseModal}>
                <Text style={styles.closeButton}>‚úï</Text>
                </TouchableOpacity>
              </View>
            
            <ScrollView 
              style={{ maxHeight: '90%' }}
              showsVerticalScrollIndicator={true}
              contentContainerStyle={{ paddingBottom: 30 }}
            >
              <View style={styles.formGroup}>
                <Text style={styles.formLabel}>First Name</Text>
                <TextInput
                  style={styles.input}
                  value={localPersonalInfo.firstname || ''}
                  onChangeText={(text) => setLocalPersonalInfo(prev => ({...prev, firstname: text}))}
                  placeholder="First Name"
                  returnKeyType="done"
                  blurOnSubmit={true}
                />
              </View>
              
              <View style={styles.formGroup}>
                <Text style={styles.formLabel}>Last Name</Text>
                <TextInput
                  style={styles.input}
                  value={localPersonalInfo.lastname || ''}
                  onChangeText={(text) => setLocalPersonalInfo(prev => ({...prev, lastname: text}))}
                  placeholder="Last Name"
                  returnKeyType="done"
                  blurOnSubmit={true}
                />
              </View>

              <View style={styles.formGroup}>
                <Text style={styles.formLabel}>Age</Text>
                <TextInput
                  style={styles.input}
                  value={localPersonalInfo.age ? String(localPersonalInfo.age) : ''}
                  onChangeText={(text) => {
                    const age = text === '' ? null : parseInt(text);
                    setLocalPersonalInfo(prev => ({...prev, age}));
                  }}
                  placeholder="Age"
                  keyboardType="number-pad"
                  returnKeyType="done"
                  blurOnSubmit={true}
                />
              </View>
              
              <View style={styles.formGroup}>
                <Text style={styles.formLabel}>Gender</Text>
                <TouchableOpacity 
                  key={`gender-dropdown-${selectedGender || 'unselected'}`}
                  style={[
                    styles.dropdownButton,
                    localPersonalInfo.gender ? styles.dropdownButtonSelected : {}
                  ]}
                  onPress={() => setShowGenderOptions(!showGenderOptions)}
                >
                  <View style={styles.dropdownContent}>
                    <Text style={styles.dropdownArrow}>{showGenderOptions ? '‚ñ≤' : '‚ñº'}</Text>
                    <Text style={[
                      styles.dropdownButtonText,
                      selectedGender ? styles.dropdownButtonTextSelected : {}
                    ]}>
                      {selectedGender ? 
                        genderOptions.find(option => option.value === selectedGender)?.label || 'Please select' : 
                        'Please select'}
                    </Text>
                  </View>
                </TouchableOpacity>
                
                {showGenderOptions && (
                  <View style={styles.optionsList}>
                    {genderOptions.map((option) => (
                      <TouchableOpacity
                        key={option.value}
                        style={[
                          styles.optionItem,
                          selectedGender === option.value ? styles.selectedOption : {}
                        ]}
                        onPress={() => handleGenderSelect(option.value)}
                      >
                        <Text style={[
                          styles.optionText,
                          selectedGender === option.value ? styles.selectedOptionText : {}
                        ]}>
                          {option.label}
                          {selectedGender === option.value && ' ‚úì'}
                        </Text>
                      </TouchableOpacity>
                    ))}
                  </View>
                )}
              </View>
              
              <View style={styles.formGroup}>
                <Text style={styles.formLabel}>Height (cm)</Text>
                <TextInput
                  style={styles.input}
                  value={localPersonalInfo.height ? String(localPersonalInfo.height) : ''}
                  onChangeText={(text) => {
                    const height = text === '' ? null : parseInt(text);
                    setLocalPersonalInfo(prev => ({...prev, height}));
                  }}
                  placeholder="Height in cm"
                  keyboardType="number-pad"
                  returnKeyType="done"
                  blurOnSubmit={true}
                />
              </View>
              
              <View style={styles.formGroup}>
                <Text style={styles.formLabel}>Weight (kg)</Text>
                <TextInput
                  style={styles.input}
                  value={localPersonalInfo.weight ? String(localPersonalInfo.weight) : ''}
                  onChangeText={(text) => {
                    const weight = text === '' ? null : parseFloat(text);
                    setLocalPersonalInfo(prev => ({...prev, weight}));
                  }}
                  placeholder="Weight in kg"
                  keyboardType="decimal-pad"
                  returnKeyType="done"
                  blurOnSubmit={true}
                />
              </View>
              
              <View style={styles.formGroup}>
                <Text style={styles.formLabel}>Fitness Level (1-10)</Text>
                <TextInput
                  style={styles.input}
                  value={(() => {
                    const val = localPersonalInfo.fitness_level ? String(localPersonalInfo.fitness_level) : '';
                    console.log(`üìä Rendering fitness_level TextInput with value: '${val}' (type: ${typeof localPersonalInfo.fitness_level}, raw: ${localPersonalInfo.fitness_level})`);
                    return val;
                  })()}
                  onChangeText={(text) => {
                    const fitnessLevel = text === '' ? null : parseInt(text);
                    console.log(`‚úèÔ∏è User entered fitness_level: ${text} (parsed to: ${fitnessLevel})`);
                    setLocalPersonalInfo(prev => ({...prev, fitness_level: fitnessLevel}));
                  }}
                  placeholder="Fitness Level (1-10)"
                  keyboardType="number-pad"
                  returnKeyType="done"
                  blurOnSubmit={true}
                />
              </View>
              
              <View style={styles.formGroup}>
                <Text style={styles.formLabel}>Stress Level (1-10)</Text>
                <TextInput
                  style={styles.input}
                  value={localPersonalInfo.stress_level ? String(localPersonalInfo.stress_level) : ''}
                  onChangeText={(text) => {
                    const stressLevel = text === '' ? null : parseInt(text);
                    setLocalPersonalInfo(prev => ({...prev, stress_level: stressLevel}));
                  }}
                  placeholder="Stress Level (1-10)"
                  keyboardType="number-pad"
                  returnKeyType="done"
                  blurOnSubmit={true}
                />
              </View>
              
              <View style={styles.formGroup}>
                <Text style={styles.formLabel}>Sleep Quality (1-10)</Text>
                <TextInput
                  style={styles.input}
                  value={localPersonalInfo.sleep_quality ? String(localPersonalInfo.sleep_quality) : ''}
                  onChangeText={(text) => {
                    const sleepQuality = text === '' ? null : parseInt(text);
                    setLocalPersonalInfo(prev => ({...prev, sleep_quality: sleepQuality}));
                  }}
                  placeholder="Sleep Quality (1-10)"
                  keyboardType="number-pad"
                  returnKeyType="done"
                  blurOnSubmit={true}
                />
              </View>
              
              <View style={styles.formGroup}>
                <Text style={styles.formLabel}>Pre-existing Conditions</Text>
                <TextInput
                  style={[styles.input, styles.textArea]}
                  value={localPersonalInfo.pre_existing_conditions}
                  onChangeText={(text) => setLocalPersonalInfo({...localPersonalInfo, pre_existing_conditions: text})}
                  placeholder="Pre-existing Conditions"
                  multiline={true}
                  numberOfLines={3}
                  blurOnSubmit={true}
                />
              </View>
              
              <View style={styles.formGroup}>
                <Text style={styles.formLabel}>Allergies</Text>
                <TextInput
                  style={[styles.input, styles.textArea]}
                  value={localPersonalInfo.allergies}
                  onChangeText={(text) => setLocalPersonalInfo({...localPersonalInfo, allergies: text})}
                  placeholder="Allergies"
                  multiline={true}
                  numberOfLines={3}
                  blurOnSubmit={true}
                />
              </View>
              
              <View style={styles.formGroup}>
                <Text style={styles.formLabel}>Smoker</Text>
                <TouchableOpacity 
                  style={[
                    styles.dropdownButton,
                    selectedSmoker ? styles.dropdownButtonSelected : {}
                  ]}
                  onPress={() => setShowSmokerOptions(!showSmokerOptions)}
                >
                  <View style={styles.dropdownContent}>
                    <Text style={styles.dropdownArrow}>{showSmokerOptions ? '‚ñ≤' : '‚ñº'}</Text>
                    <Text style={[
                      styles.dropdownButtonText,
                      selectedSmoker ? styles.dropdownButtonTextSelected : {}
                    ]}>
                      {selectedSmoker ? 
                        smokerOptions.find(option => option.value === selectedSmoker)?.label || 'Please select' : 
                        'Please select'}
                    </Text>
                  </View>
                </TouchableOpacity>
                
                {showSmokerOptions && (
                  <View style={styles.optionsList}>
                    {smokerOptions.map((option) => (
                      <TouchableOpacity
                        key={option.value}
                        style={[
                          styles.optionItem,
                          selectedSmoker === option.value ? styles.selectedOption : {}
                        ]}
                        onPress={() => handleSmokerSelect(option.value)}
                      >
                        <Text style={[
                          styles.optionText,
                          selectedSmoker === option.value ? styles.selectedOptionText : {}
                        ]}>
                          {option.label}
                          {selectedSmoker === option.value && ' ‚úì'}
                        </Text>
                      </TouchableOpacity>
                    ))}
                  </View>
                )}
              </View>
              
              <View style={styles.formGroup}>
                <Text style={styles.formLabel}>Alcohol Consumption</Text>
                <TouchableOpacity 
                  style={[
                    styles.dropdownButton,
                    selectedAlcohol ? styles.dropdownButtonSelected : {}
                  ]}
                  onPress={() => setShowAlcoholOptions(!showAlcoholOptions)}
                >
                  <View style={styles.dropdownContent}>
                    <Text style={styles.dropdownArrow}>{showAlcoholOptions ? '‚ñ≤' : '‚ñº'}</Text>
                    <Text style={[
                      styles.dropdownButtonText,
                      selectedAlcohol ? styles.dropdownButtonTextSelected : {}
                    ]}>
                      {selectedAlcohol ? 
                        alcoholOptions.find(option => option.value === selectedAlcohol)?.label || 'Please select' : 
                        'Please select'}
                    </Text>
                  </View>
                </TouchableOpacity>
                
                {showAlcoholOptions && (
                  <View style={styles.optionsList}>
                    {alcoholOptions.map((option) => (
                      <TouchableOpacity
                        key={option.value}
                        style={[
                          styles.optionItem,
                          selectedAlcohol === option.value ? styles.selectedOption : {}
                        ]}
                        onPress={() => handleAlcoholSelect(option.value)}
                      >
                        <Text style={[
                          styles.optionText,
                          selectedAlcohol === option.value ? styles.selectedOptionText : {}
                        ]}>
                          {option.label}
                          {selectedAlcohol === option.value && ' ‚úì'}
                        </Text>
                      </TouchableOpacity>
                    ))}
                  </View>
                )}
              </View>
              
              {/* Marijuana Consumption */}
              <View style={styles.formGroup}>
                <Text style={styles.formLabel}>Marijuana Consumption</Text>
                <TouchableOpacity 
                  style={[
                    styles.dropdownButton,
                    localPersonalInfo.marijuana_consumption ? styles.dropdownButtonSelected : {}
                  ]}
                  onPress={() => setShowMarijuanaOptions(!showMarijuanaOptions)}
                >
                  <View style={styles.dropdownContent}>
                    <Text style={styles.dropdownArrow}>{showMarijuanaOptions ? '‚ñ≤' : '‚ñº'}</Text>
                    <Text style={[
                      styles.dropdownButtonText,
                      localPersonalInfo.marijuana_consumption ? styles.dropdownButtonTextSelected : {}
                    ]}>
                      {localPersonalInfo.marijuana_consumption ? 
                        marijuanaOptions.find(option => option.value === localPersonalInfo.marijuana_consumption)?.label || 'Please select' : 
                        'Please select'}
                    </Text>
                  </View>
                </TouchableOpacity>
                
                {showMarijuanaOptions && (
                  <View style={styles.optionsList}>
                    {marijuanaOptions.map((option) => (
                      <TouchableOpacity
                        key={option.value}
                        style={[
                          styles.optionItem,
                          localPersonalInfo.marijuana_consumption === option.value ? styles.selectedOption : {}
                        ]}
                        onPress={() => handleMarijuanaSelect(option.value)}
                      >
                        <Text style={[
                          styles.optionText,
                          localPersonalInfo.marijuana_consumption === option.value ? styles.selectedOptionText : {}
                        ]}>
                          {option.label}
                          {localPersonalInfo.marijuana_consumption === option.value && ' ‚úì'}
                        </Text>
                      </TouchableOpacity>
                    ))}
                  </View>
                )}
              </View>

              {/* Diet Type */}
              <View style={styles.formGroup}>
                <Text style={styles.formLabel}>Diet Type</Text>
                <TouchableOpacity 
                  style={[
                    styles.dropdownButton,
                    localPersonalInfo.diet_type ? styles.dropdownButtonSelected : {}
                  ]}
                  onPress={() => setShowDietOptions(!showDietOptions)}
                >
                  <View style={styles.dropdownContent}>
                    <Text style={styles.dropdownArrow}>{showDietOptions ? '‚ñ≤' : '‚ñº'}</Text>
                    <Text style={[
                      styles.dropdownButtonText,
                      localPersonalInfo.diet_type ? styles.dropdownButtonTextSelected : {}
                    ]}>
                      {localPersonalInfo.diet_type ? 
                        dietOptions.find(option => option.value === localPersonalInfo.diet_type)?.label || 'Please select' : 
                        'Please select'}
                    </Text>
                  </View>
                </TouchableOpacity>
                
                {showDietOptions && (
                  <View style={styles.optionsList}>
                    {dietOptions.map((option) => (
                <TouchableOpacity 
                        key={option.value}
                        style={[
                          styles.optionItem,
                          localPersonalInfo.diet_type === option.value ? styles.selectedOption : {}
                        ]}
                        onPress={() => handleDietSelect(option.value)}
                      >
                        <Text style={[
                          styles.optionText,
                          localPersonalInfo.diet_type === option.value ? styles.selectedOptionText : {}
                        ]}>
                          {option.label}
                          {localPersonalInfo.diet_type === option.value && ' ‚úì'}
                        </Text>
                </TouchableOpacity>
                    ))}
                  </View>
                )}
              </View>

              {/* Cold Showers */}
              <View style={styles.formGroup}>
                <Text style={styles.formLabel}>Cold Showers / Ice Baths</Text>
                <TouchableOpacity 
                  style={[
                    styles.dropdownButton,
                    localPersonalInfo.cold_showers ? styles.dropdownButtonSelected : {}
                  ]}
                  onPress={() => setShowColdShowerOptions(!showColdShowerOptions)}
                >
                  <View style={styles.dropdownContent}>
                    <Text style={styles.dropdownArrow}>{showColdShowerOptions ? '‚ñ≤' : '‚ñº'}</Text>
                    <Text style={[
                      styles.dropdownButtonText,
                      localPersonalInfo.cold_showers ? styles.dropdownButtonTextSelected : {}
                    ]}>
                      {localPersonalInfo.cold_showers ? 
                        yesNoOptions.find(option => option.value === localPersonalInfo.cold_showers)?.label || 'Please select' : 
                        'Please select'}
                    </Text>
                  </View>
                </TouchableOpacity>
                
                {showColdShowerOptions && (
                  <View style={styles.optionsList}>
                    {yesNoOptions.map((option) => (
                      <TouchableOpacity
                        key={option.value}
                        style={[
                          styles.optionItem,
                          localPersonalInfo.cold_showers === option.value ? styles.selectedOption : {}
                        ]}
                        onPress={() => handleColdShowerSelect(option.value)}
                      >
                        <Text style={[
                          styles.optionText,
                          localPersonalInfo.cold_showers === option.value ? styles.selectedOptionText : {}
                        ]}>
                          {option.label}
                          {localPersonalInfo.cold_showers === option.value && ' ‚úì'}
                        </Text>
                      </TouchableOpacity>
                    ))}
                  </View>
                )}
              </View>

              {/* Meditation */}
              <View style={styles.formGroup}>
                <Text style={styles.formLabel}>Meditation Practice</Text>
                <TouchableOpacity 
                  style={[
                    styles.dropdownButton,
                    localPersonalInfo.meditation ? styles.dropdownButtonSelected : {}
                  ]}
                  onPress={() => setShowMeditationOptions(!showMeditationOptions)}
                >
                  <View style={styles.dropdownContent}>
                    <Text style={styles.dropdownArrow}>{showMeditationOptions ? '‚ñ≤' : '‚ñº'}</Text>
                    <Text style={[
                      styles.dropdownButtonText,
                      localPersonalInfo.meditation ? styles.dropdownButtonTextSelected : {}
                    ]}>
                      {localPersonalInfo.meditation ? 
                        yesNoOptions.find(option => option.value === localPersonalInfo.meditation)?.label || 'Please select' : 
                        'Please select'}
                    </Text>
                  </View>
                </TouchableOpacity>
                
                {showMeditationOptions && (
                  <View style={styles.optionsList}>
                    {yesNoOptions.map((option) => (
                      <TouchableOpacity
                        key={option.value}
                        style={[
                          styles.optionItem,
                          localPersonalInfo.meditation === option.value ? styles.selectedOption : {}
                        ]}
                        onPress={() => handleMeditationSelect(option.value)}
                      >
                        <Text style={[
                          styles.optionText,
                          localPersonalInfo.meditation === option.value ? styles.selectedOptionText : {}
                        ]}>
                          {option.label}
                          {localPersonalInfo.meditation === option.value && ' ‚úì'}
                        </Text>
                      </TouchableOpacity>
                    ))}
                  </View>
                )}
              </View>

              {/* Sauna Use */}
              <View style={styles.formGroup}>
                <Text style={styles.formLabel}>Regular Sauna Use</Text>
                <TouchableOpacity 
                  style={[
                    styles.dropdownButton,
                    localPersonalInfo.sauna_use ? styles.dropdownButtonSelected : {}
                  ]}
                  onPress={() => setShowSaunaOptions(!showSaunaOptions)}
                >
                  <View style={styles.dropdownContent}>
                    <Text style={styles.dropdownArrow}>{showSaunaOptions ? '‚ñ≤' : '‚ñº'}</Text>
                    <Text style={[
                      styles.dropdownButtonText,
                      localPersonalInfo.sauna_use ? styles.dropdownButtonTextSelected : {}
                    ]}>
                      {localPersonalInfo.sauna_use ? 
                        yesNoOptions.find(option => option.value === localPersonalInfo.sauna_use)?.label || 'Please select' : 
                        'Please select'}
                    </Text>
                  </View>
                </TouchableOpacity>
                
                {showSaunaOptions && (
                  <View style={styles.optionsList}>
                    {yesNoOptions.map((option) => (
                      <TouchableOpacity
                        key={option.value}
                        style={[
                          styles.optionItem,
                          localPersonalInfo.sauna_use === option.value ? styles.selectedOption : {}
                        ]}
                        onPress={() => handleSaunaSelect(option.value)}
                      >
                        <Text style={[
                          styles.optionText,
                          localPersonalInfo.sauna_use === option.value ? styles.selectedOptionText : {}
                        ]}>
                          {option.label}
                          {localPersonalInfo.sauna_use === option.value && ' ‚úì'}
                        </Text>
                      </TouchableOpacity>
                    ))}
                  </View>
                )}
              </View>

              {/* Sleep Medication */}
              <View style={styles.formGroup}>
                <Text style={styles.formLabel}>Sleep Medication</Text>
                <TouchableOpacity 
                  style={[
                    styles.dropdownButton,
                    localPersonalInfo.sleep_medication ? styles.dropdownButtonSelected : {}
                  ]}
                  onPress={() => setShowSleepMedicationOptions(!showSleepMedicationOptions)}
                >
                  <View style={styles.dropdownContent}>
                    <Text style={styles.dropdownArrow}>{showSleepMedicationOptions ? '‚ñ≤' : '‚ñº'}</Text>
                    <Text style={[
                      styles.dropdownButtonText,
                      localPersonalInfo.sleep_medication ? styles.dropdownButtonTextSelected : {}
                    ]}>
                      {localPersonalInfo.sleep_medication ? 
                        yesNoOptions.find(option => option.value === localPersonalInfo.sleep_medication)?.label || 'Please select' : 
                        'Please select'}
                    </Text>
                  </View>
                </TouchableOpacity>
                
                {showSleepMedicationOptions && (
                  <View style={styles.optionsList}>
                    {yesNoOptions.map((option) => (
                      <TouchableOpacity
                        key={option.value}
                        style={[
                          styles.optionItem,
                          localPersonalInfo.sleep_medication === option.value ? styles.selectedOption : {}
                        ]}
                        onPress={() => handleSleepMedicationSelect(option.value)}
                      >
                        <Text style={[
                          styles.optionText,
                          localPersonalInfo.sleep_medication === option.value ? styles.selectedOptionText : {}
                        ]}>
                          {option.label}
                          {localPersonalInfo.sleep_medication === option.value && ' ‚úì'}
                        </Text>
                      </TouchableOpacity>
                    ))}
                  </View>
                )}
              </View>

              {/* Blue Light Glasses */}
              <View style={styles.formGroup}>
                <Text style={styles.formLabel}>Blue Light Blocking Glasses</Text>
                <TouchableOpacity 
                  style={[
                    styles.dropdownButton,
                    localPersonalInfo.blue_light_glasses ? styles.dropdownButtonSelected : {}
                  ]}
                  onPress={() => setShowBlueLightGlassesOptions(!showBlueLightGlassesOptions)}
                >
                  <View style={styles.dropdownContent}>
                    <Text style={styles.dropdownArrow}>{showBlueLightGlassesOptions ? '‚ñ≤' : '‚ñº'}</Text>
                    <Text style={[
                      styles.dropdownButtonText,
                      localPersonalInfo.blue_light_glasses ? styles.dropdownButtonTextSelected : {}
                    ]}>
                      {localPersonalInfo.blue_light_glasses ? 
                        yesNoOptions.find(option => option.value === localPersonalInfo.blue_light_glasses)?.label || 'Please select' : 
                        'Please select'}
                    </Text>
                  </View>
                </TouchableOpacity>
                
                {showBlueLightGlassesOptions && (
                  <View style={styles.optionsList}>
                    {yesNoOptions.map((option) => (
                      <TouchableOpacity
                        key={option.value}
                        style={[
                          styles.optionItem,
                          localPersonalInfo.blue_light_glasses === option.value ? styles.selectedOption : {}
                        ]}
                        onPress={() => handleBlueLightGlassesSelect(option.value)}
                      >
                        <Text style={[
                          styles.optionText,
                          localPersonalInfo.blue_light_glasses === option.value ? styles.selectedOptionText : {}
                        ]}>
                          {option.label}
                          {localPersonalInfo.blue_light_glasses === option.value && ' ‚úì'}
                        </Text>
                      </TouchableOpacity>
                    ))}
                  </View>
                )}
              </View>

              {/* Intermittent Fasting */}
              <View style={styles.formGroup}>
                <Text style={styles.formLabel}>Intermittent Fasting</Text>
                <TouchableOpacity 
                  style={[
                    styles.dropdownButton,
                    localPersonalInfo.intermittent_fasting ? styles.dropdownButtonSelected : {}
                  ]}
                  onPress={() => setShowIntermittentFastingOptions(!showIntermittentFastingOptions)}
                >
                  <View style={styles.dropdownContent}>
                    <Text style={styles.dropdownArrow}>{showIntermittentFastingOptions ? '‚ñ≤' : '‚ñº'}</Text>
                    <Text style={[
                      styles.dropdownButtonText,
                      localPersonalInfo.intermittent_fasting ? styles.dropdownButtonTextSelected : {}
                    ]}>
                      {localPersonalInfo.intermittent_fasting ? 
                        yesNoOptions.find(option => option.value === localPersonalInfo.intermittent_fasting)?.label || 'Please select' : 
                        'Please select'}
                    </Text>
                  </View>
                </TouchableOpacity>
                
                {showIntermittentFastingOptions && (
                  <View style={styles.optionsList}>
                    {yesNoOptions.map((option) => (
                      <TouchableOpacity
                        key={option.value}
                        style={[
                          styles.optionItem,
                          localPersonalInfo.intermittent_fasting === option.value ? styles.selectedOption : {}
                        ]}
                        onPress={() => handleIntermittentFastingSelect(option.value)}
                      >
                        <Text style={[
                          styles.optionText,
                          localPersonalInfo.intermittent_fasting === option.value ? styles.selectedOptionText : {}
                        ]}>
                          {option.label}
                          {localPersonalInfo.intermittent_fasting === option.value && ' ‚úì'}
                        </Text>
                      </TouchableOpacity>
                    ))}
                  </View>
                )}
              </View>

              {/* Sleep Mask */}
              <View style={styles.formGroup}>
                <Text style={styles.formLabel}>Sleep Mask</Text>
                <TouchableOpacity 
                  style={[
                    styles.dropdownButton,
                    localPersonalInfo.sleep_mask ? styles.dropdownButtonSelected : {}
                  ]}
                  onPress={() => setShowSleepMaskOptions(!showSleepMaskOptions)}
                >
                  <View style={styles.dropdownContent}>
                    <Text style={styles.dropdownArrow}>{showSleepMaskOptions ? '‚ñ≤' : '‚ñº'}</Text>
                    <Text style={[
                      styles.dropdownButtonText,
                      localPersonalInfo.sleep_mask ? styles.dropdownButtonTextSelected : {}
                    ]}>
                      {localPersonalInfo.sleep_mask ? 
                        yesNoOptions.find(option => option.value === localPersonalInfo.sleep_mask)?.label || 'Please select' : 
                        'Please select'}
                    </Text>
                  </View>
                </TouchableOpacity>
                
                {showSleepMaskOptions && (
                  <View style={styles.optionsList}>
                    {yesNoOptions.map((option) => (
                      <TouchableOpacity
                        key={option.value}
                        style={[
                          styles.optionItem,
                          localPersonalInfo.sleep_mask === option.value ? styles.selectedOption : {}
                        ]}
                        onPress={() => handleSleepMaskSelect(option.value)}
                      >
                        <Text style={[
                          styles.optionText,
                          localPersonalInfo.sleep_mask === option.value ? styles.selectedOptionText : {}
                        ]}>
                          {option.label}
                          {localPersonalInfo.sleep_mask === option.value && ' ‚úì'}
                        </Text>
                      </TouchableOpacity>
                    ))}
                  </View>
                )}
              </View>

              {/* Seasonal Allergies */}
              <View style={styles.formGroup}>
                <Text style={styles.formLabel}>Seasonal Allergies</Text>
                <TouchableOpacity 
                  style={[
                    styles.dropdownButton,
                    localPersonalInfo.seasonal_allergies ? styles.dropdownButtonSelected : {}
                  ]}
                  onPress={() => setShowSeasonalAllergiesOptions(!showSeasonalAllergiesOptions)}
                >
                  <View style={styles.dropdownContent}>
                    <Text style={styles.dropdownArrow}>{showSeasonalAllergiesOptions ? '‚ñ≤' : '‚ñº'}</Text>
                    <Text style={[
                      styles.dropdownButtonText,
                      localPersonalInfo.seasonal_allergies ? styles.dropdownButtonTextSelected : {}
                    ]}>
                      {localPersonalInfo.seasonal_allergies ? 
                        yesNoOptions.find(option => option.value === localPersonalInfo.seasonal_allergies)?.label || 'Please select' : 
                        'Please select'}
                    </Text>
                  </View>
                </TouchableOpacity>
                
                {showSeasonalAllergiesOptions && (
                  <View style={styles.optionsList}>
                    {yesNoOptions.map((option) => (
                      <TouchableOpacity
                        key={option.value}
                        style={[
                          styles.optionItem,
                          localPersonalInfo.seasonal_allergies === option.value ? styles.selectedOption : {}
                        ]}
                        onPress={() => handleSeasonalAllergiesSelect(option.value)}
                      >
                        <Text style={[
                          styles.optionText,
                          localPersonalInfo.seasonal_allergies === option.value ? styles.selectedOptionText : {}
                        ]}>
                          {option.label}
                          {localPersonalInfo.seasonal_allergies === option.value && ' ‚úì'}
                        </Text>
                      </TouchableOpacity>
                    ))}
                  </View>
                )}
              </View>

              {/* Caffeine Consumption */}
              <View style={styles.formGroup}>
                <Text style={styles.formLabel}>Caffeine Consumption</Text>
                <TouchableOpacity 
                  style={[
                    styles.dropdownButton,
                    localPersonalInfo.caffeine_consumption ? styles.dropdownButtonSelected : {}
                  ]}
                  onPress={() => setShowCaffeineConsumptionOptions(!showCaffeineConsumptionOptions)}
                >
                  <View style={styles.dropdownContent}>
                    <Text style={styles.dropdownArrow}>{showCaffeineConsumptionOptions ? '‚ñ≤' : '‚ñº'}</Text>
                    <Text style={[
                      styles.dropdownButtonText,
                      localPersonalInfo.caffeine_consumption ? styles.dropdownButtonTextSelected : {}
                    ]}>
                      {localPersonalInfo.caffeine_consumption ? 
                        yesNoOptions.find(option => option.value === localPersonalInfo.caffeine_consumption)?.label || 'Please select' : 
                        'Please select'}
                    </Text>
                  </View>
                </TouchableOpacity>
                
                {showCaffeineConsumptionOptions && (
                  <View style={styles.optionsList}>
                    {yesNoOptions.map((option) => (
                      <TouchableOpacity
                        key={option.value}
                        style={[
                          styles.optionItem,
                          localPersonalInfo.caffeine_consumption === option.value ? styles.selectedOption : {}
                        ]}
                        onPress={() => handleCaffeineConsumptionSelect(option.value)}
                      >
                        <Text style={[
                          styles.optionText,
                          localPersonalInfo.caffeine_consumption === option.value ? styles.selectedOptionText : {}
                        ]}>
                          {option.label}
                          {localPersonalInfo.caffeine_consumption === option.value && ' ‚úì'}
                        </Text>
                      </TouchableOpacity>
                    ))}
                  </View>
                )}
              </View>
            </ScrollView>
            
            <View style={styles.modalButtons}>
              <TouchableOpacity 
                style={styles.autoFillButton} 
                onPress={() => {
                  // Arrays to store found activities by type
                  const exerciseActivities = [];
                  const relaxationActivities = [];
                  let exerciseDuration = 0;
                  let relaxationDuration = 0;
                  let hasMindfulMinutes = false;
                  
                  // Check if there are activities in the training section
                  if (garminData?.activity?.daily_activities && 
                      garminData.activity.daily_activities.length > 0) {
                        
                    // Categorize activities
                    garminData.activity.daily_activities.forEach(activity => {
                      const activityType = activity.type.toLowerCase();
                      
                      // Check if it's a relaxation activity (yoga or meditation)
                      if (activityType.includes('yoga') || 
                          activityType.includes('meditation') || 
                          activityType.includes('mindful')) {
                        relaxationActivities.push(activity.type);
                        relaxationDuration += activity.duration_minutes;
                      } 
                      // Otherwise, it's a regular exercise
                      else {
                        exerciseActivities.push(activity.type);
                        exerciseDuration += activity.duration_minutes;
                      }
                    });
                  }
                  
                  // Check for mindful minutes
                  if (garminData?.activity?.mindful_minutes && 
                      garminData.activity.mindful_minutes > 0) {
                    hasMindfulMinutes = true;
                    
                    // Only add mindful minutes to duration if no meditation activities found
                    if (!relaxationActivities.some(a => 
                        a.toLowerCase().includes('meditation') || 
                        a.toLowerCase().includes('mindful'))) {
                      relaxationDuration += garminData.activity.mindful_minutes;
                    }
                  }
                  
                  // Update exercise data if found
                  if (exerciseActivities.length > 0) {
                    setDailySurveyResponses(prev => ({
                      ...prev,
                      exercise: true,
                      exercise_type: exerciseActivities.join(", "),
                      exercise_duration: exerciseDuration.toString()
                    }));
                  }
                  
                  // Update relaxation data if found
                  if (relaxationActivities.length > 0 || hasMindfulMinutes) {
                    const hasYoga = relaxationActivities.some(a => a.toLowerCase().includes('yoga'));
                    const hasMeditation = relaxationActivities.some(a => 
                      a.toLowerCase().includes('meditation') || 
                      a.toLowerCase().includes('mindful')) || hasMindfulMinutes;
                    
                    setDailySurveyResponses(prev => ({
                      ...prev,
                      relaxation: true,
                      relaxation_duration: relaxationDuration.toString(),
                      relaxation_meditation: hasMeditation,
                      relaxation_other: hasYoga,
                      relaxation_other_text: hasYoga ? 'Yoga' : prev.relaxation_other_text
                    }));
                  }
                  
                  // Show message if no data found
                  if (exerciseActivities.length === 0 && 
                      relaxationActivities.length === 0 && 
                      !hasMindfulMinutes) {
                    Alert.alert(
                      "No Activity Data",
                      "No exercise or relaxation activities were found in your data."
                    );
                  }
                }}
              >
                <Text style={styles.modalButtonText}>Autofill</Text>
              </TouchableOpacity>
              
              <TouchableOpacity style={styles.modalSubmitButton} onPress={submitSurvey}>
                <Text style={styles.modalButtonText}>Submit</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>

      {/* Personal Info Modal */}
      <PersonalInfoModal />
    </View>
  );
};

export default HomeScreen;
